diff --git a/src/game/PlayerbotAI.cpp b/src/game/PlayerbotAI.cpp
new file mode
--- /dev/null
+++ b/src/game/PlayerbotAI.cpp
@@ -0,0 +1,1596 @@
+#include "Common.h"
+#include "Database/DatabaseEnv.h"
+//#include "Database/DBCStores.h"
+#include "World.h"
+#include "SpellMgr.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotDeathKnightAI.h"
+#include "PlayerbotDruidAI.h"
+#include "PlayerbotHunterAI.h"
+#include "PlayerbotMageAI.h"
+#include "PlayerbotPaladinAI.h"
+#include "PlayerbotPriestAI.h"
+#include "PlayerbotRogueAI.h"
+#include "PlayerbotShamanAI.h"
+#include "PlayerbotWarlockAI.h"
+#include "PlayerbotWarriorAI.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "Chat.h"
+#include "WorldPacket.h"
+#include "Spell.h"
+#include "Unit.h"
+#include "SpellAuras.h"
+#include "SharedDefines.h"
+
+/*
+ * Packets often compress the GUID (global unique identifier)
+ * This function extracts the guid from the packet and decompresses it.
+ * The first word (8 bits) in the packet represents how many words in the following packet(s) are part of
+ * the guid and what weight they hold. I call it the mask. For example) if mask is 01001001,
+ * there will be only 3 words. The first word is shifted to the left 0 times,
+ * the second is shifted 3 times, and the third is shifted 6.
+ */
+uint64 extractGuid(WorldPacket& packet) {
+uint8 mask; packet >> mask;
+uint64 guid = 0;
+uint8 bit = 0;
+uint8 testMask = 1;
+while (true) {
+if (mask & testMask) {
+uint8 word; packet >> word;
+guid += (word << bit);
+}
+if (bit == 7) break;
+++bit;
+testMask <<= 1;
+}
+return guid;
+}
+
+PlayerbotAI::PlayerbotAI(Player* const master, Player* const bot): m_master(master), m_bot(bot),
+m_ignoreAIUpdatesUntilTime(0), m_combatOrder(ORDERS_NONE), m_ScenarioType(SCENARIO_PVEEASY),
+m_TimeDoneEating(0), m_TimeDoneDrinking(0), m_CurrentlyCastingSpellId(0), m_IsFollowingMaster(true),
+m_spellIdCommand(0), m_targetGuidCommand(0), m_classAI(0) {
+
+// get class specific ai
+switch(m_bot->getClass()) {
+case CLASS_PRIEST:
+m_classAI = (PlayerbotClassAI*)new PlayerbotPriestAI(master, m_bot, this);
+break;
+case CLASS_MAGE:
+m_classAI = (PlayerbotClassAI*)new PlayerbotMageAI(master, m_bot, this);
+break;
+case CLASS_WARLOCK:
+m_classAI = (PlayerbotClassAI*)new PlayerbotWarlockAI(master, m_bot, this);
+break;
+case CLASS_WARRIOR:
+m_classAI = (PlayerbotClassAI*)new PlayerbotWarriorAI(master, m_bot, this);
+break;
+case CLASS_SHAMAN:
+m_classAI = (PlayerbotClassAI*)new PlayerbotShamanAI(master, m_bot, this);
+break;
+case CLASS_PALADIN:
+m_classAI = (PlayerbotClassAI*)new PlayerbotPaladinAI(master, m_bot, this);
+break;
+case CLASS_ROGUE:
+m_classAI = (PlayerbotClassAI*)new PlayerbotRogueAI(master, m_bot, this);
+break;
+case CLASS_DRUID:
+m_classAI = (PlayerbotClassAI*)new PlayerbotDruidAI(master, m_bot, this);
+break;
+case CLASS_HUNTER:
+m_classAI = (PlayerbotClassAI*)new PlayerbotHunterAI(master, m_bot, this);
+break;
+case CLASS_DEATH_KNIGHT:
+m_classAI = (PlayerbotClassAI*)new PlayerbotDeathKnightAI(master, m_bot, this);
+break;
+}
+}
+PlayerbotAI::~PlayerbotAI() {}
+
+// finds spell ID for matching substring args
+// in priority of full text match, spells not taking reagents, and highest rank
+uint32 PlayerbotAI::getSpellId(const char* args) const {
+    if(!*args)
+        return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if(!Utf8toWStr(namepart,wnamepart))
+        return 0;
+
+    // converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+
+int loc = m_master->GetSession()->GetSessionDbcLocale();
+
+uint32 foundSpellId = 0;
+bool foundExactMatch = false;
+bool foundMatchUsesNoReagents = false;
+
+for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+{
+uint32 spellId = itr->first;
+
+if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || IsPassiveSpell(spellId))
+continue;
+
+const SpellEntry* pSpellInfo = sSpellStore.LookupEntry(spellId);
+if (! pSpellInfo)
+continue;
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if(name.empty() || !Utf8FitTo(name, wnamepart))
+        	continue;
+
+bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+bool usesNoReagents = (pSpellInfo->Reagent[0] <=  0) ? true : false;
+
+// if we already found a spell
+bool useThisSpell = true;
+if (foundSpellId > 0) {
+if (isExactMatch && ! foundExactMatch) {}
+else if (usesNoReagents && ! foundMatchUsesNoReagents) {}
+else if (spellId > foundSpellId) {}
+else
+useThisSpell = false;
+}
+if (useThisSpell) {
+foundSpellId = spellId;
+foundExactMatch = isExactMatch;
+foundMatchUsesNoReagents = usesNoReagents;
+}
+}
+
+    return foundSpellId;
+}
+
+/*
+ * Send a list of equipment that is in bot's inventor that is currently unequipped.
+ * This is called when the master is inspecting the bot.
+ */
+void PlayerbotAI::SendNotEquipList(Player& player) {
+
+// find all unequipped items and put them in
+// a vector of dynamically created lists where the vector index is from 0-18
+// and the list contains Item* that can be equipped to that slot
+// Note: each dynamically created list in the vector must be deleted at end
+// so NO EARLY RETURNS!
+// see enum EquipmentSlots in Player.h to see what equipment slot each index in vector
+// is assigned to. (The first is EQUIPMENT_SLOT_HEAD=0, and last is EQUIPMENT_SLOT_TABARD=18)
+std::list<Item*>* equip[19];
+for (uint8 i=0; i < 19; ++i) equip[i] = NULL;
+
+    // list out items in main backpack
+    for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++) {
+    Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+    if (! pItem) continue;
+
+        uint16 dest;
+        uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag() );
+        if( msg != EQUIP_ERR_OK ) continue;
+
+        // the dest looks like it includes the old loc in the 8 higher bits
+        // so casting it to a uint8 strips them
+        uint8 equipSlot = uint8(dest);
+        if (!(equipSlot >= 0 && equipSlot < 19)) continue;
+
+        // create a list if one doesn't already exist
+        if (equip[equipSlot] == NULL)
+        	equip[equipSlot] = new std::list<Item*>;
+
+        std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+        itemListForEqSlot->push_back(pItem);
+    }
+
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) {
+    const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+    if (pBag) {
+    for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot) {
+    Item* const pItem = m_bot->GetItemByPos(bag, slot);
+    if (! pItem) continue;
+
+        uint16 equipSlot;
+        uint8 msg = m_bot->CanEquipItem(NULL_SLOT, equipSlot, pItem, !pItem->IsBag() );
+        if( msg != EQUIP_ERR_OK ) continue;
+        if (!(equipSlot >= 0 && equipSlot < 19)) continue;
+
+        // create a list if one doesn't already exist
+        if (equip[equipSlot] == NULL)
+        equip[equipSlot] = new std::list<Item*>;
+
+        std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+        itemListForEqSlot->push_back(pItem);
+    }
+    }
+    }
+
+TellMaster("Here's all the items in my inventory that I can equip.");
+ChatHandler ch(m_master);
+
+const std::string descr[]  = {"head","neck","shoulders","body","chest","waist","legs","feet","wrists",
+"hands","finger1","finger2","trinket1","trinket2","back","mainhand","offhand","ranged","tabard"};
+
+// now send client all items that can be equipped by slot
+for (uint8 equipSlot=0; equipSlot< 19; ++equipSlot) {
+if (equip[equipSlot] == NULL) continue;
+        std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+std::ostringstream out;
+out << descr[equipSlot] << ": ";
+for (std::list<Item*>::iterator it = itemListForEqSlot->begin(); it != itemListForEqSlot->end(); ++it) {
+const ItemPrototype* const pItemProto = (*it)->GetProto();
+    out << " |cffffffff|Hitem:" << pItemProto->ItemId << ":0:0:0:0:0:0:0"
+<< "|h[" << pItemProto->Name1 << "]|h|r";
+}
+ch.SendSysMessage(out.str().c_str());
+
+delete itemListForEqSlot; // delete list of Item*
+}
+}
+
+void PlayerbotAI::HandleMasterOutgoingPacket(const WorldPacket& packet, WorldSession& masterSession) {
+/*
+const char* oc = LookupOpcodeName(packet.GetOpcode());
+
+std::ostringstream out;
+out << "out: " << oc;
+sLog.outError(out.str().c_str());
+*/
+}
+
+void PlayerbotAI::HandleMasterIncomingPacket(const WorldPacket& packet, WorldSession& masterSession) {
+switch(packet.GetOpcode()) {
+
+// If master inspects one of his bots, give the master useful info in chat window
+// such as inventory that can be equipped
+case CMSG_INSPECT: {
+WorldPacket p(packet);
+p.rpos(0); // reset reader
+    uint64 guid; p >> guid;
+    Player* const bot = masterSession.GetPlayerBot(guid);
+    if (! bot) return;
+    bot->GetPlayerbotAI()->SendNotEquipList(*bot);
+}
+
+// handle emotes from the master
+//case CMSG_EMOTE:
+case CMSG_TEXT_EMOTE: {
+WorldPacket p(packet);
+p.rpos(0); // reset reader
+uint32 emoteNum;
+p >> emoteNum;
+
+/*
+std::ostringstream out;
+out << "emote is: " << emoteNum;
+    ChatHandler ch(masterSession.GetPlayer());
+    ch.SendSysMessage(out.str().c_str());
+    */
+    switch(emoteNum) {
+
+case TEXTEMOTE_BOW: {
+// Buff anyone who bows before me. Useful for players not in bot's group
+// How do I get correct target???
+//Player* const pPlayer = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+//if (pPlayer->GetPlayerbotAI()->GetClassAI()) 	
+//	pPlayer->GetPlayerbotAI()->GetClassAI()->BuffPlayer(pPlayer);
+return;
+}
+
+case TEXTEMOTE_BONK: {
+Player* const pPlayer = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+if (! pPlayer || ! pPlayer->GetPlayerbotAI()) return;
+PlayerbotAI* const pBot = pPlayer->GetPlayerbotAI();
+
+    ChatHandler ch(masterSession.GetPlayer());
+    { 	std::ostringstream out;
+out << "time(0): " << time(0)
+<< " m_ignoreAIUpdatesUntilTime: " << pBot->m_ignoreAIUpdatesUntilTime;
+ch.SendSysMessage(out.str().c_str());
+    }
+    { 	std::ostringstream out;
+out << "m_TimeDoneEating: " << pBot->m_TimeDoneEating
+<< " m_TimeDoneDrinking: " << pBot->m_TimeDoneDrinking;
+ch.SendSysMessage(out.str().c_str());
+    }
+    { 	std::ostringstream out;
+out << "m_CurrentlyCastingSpellId: " << pBot->m_CurrentlyCastingSpellId;
+ch.SendSysMessage(out.str().c_str());
+    }
+    { 	std::ostringstream out;
+out << "m_IsFollowingMaster: " << pBot->m_IsFollowingMaster;
+ch.SendSysMessage(out.str().c_str());
+    }
+    { 	std::ostringstream out;
+out << "IsBeingTeleported() " << pBot->m_bot->IsBeingTeleported();
+ch.SendSysMessage(out.str().c_str());
+    }
+    { 	std::ostringstream out;
+bool tradeActive = (pBot->m_bot->GetTrader()) ? true : false;
+out << "tradeActive: " << tradeActive;
+ch.SendSysMessage(out.str().c_str());
+    }
+    { 	std::ostringstream out;
+out << "IsCharmed() " << pBot->m_bot->isCharmed();
+ch.SendSysMessage(out.str().c_str());
+    }
+return;
+}
+
+case TEXTEMOTE_EAT:
+case TEXTEMOTE_DRINK: {
+for (PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it) {
+Player* const bot = it->second;
+bot->GetPlayerbotAI()->Feast();
+}
+return;
+}
+
+// emote to stay
+case TEXTEMOTE_STAND: {
+Player* const bot = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+if (bot) bot->GetPlayerbotAI()->Stay();
+else {
+for (PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it) {
+Player* const bot = it->second;
+bot->GetPlayerbotAI()->Stay();
+}
+}
+return;
+}
+
+// 324 is the followme emote (not defined in enum)
+// if master has bot selected then only bot follows, else all bots follow
+case 324:
+case TEXTEMOTE_WAVE: {
+Player* const bot = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+if (bot) bot->GetPlayerbotAI()->Follow(* masterSession.GetPlayer());
+else {
+for (PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it) {
+Player* const bot = it->second;
+bot->GetPlayerbotAI()->Follow(* masterSession.GetPlayer());
+}
+}
+return;
+}
+    }
+}
+/*
+
+default: {
+        const char* oc = LookupOpcodeName(packet.GetOpcode());
+    ChatHandler ch(masterSession.GetPlayer());
+    ch.SendSysMessage(oc);
+
+    std::ostringstream out;
+    out << "in: " << oc;
+    sLog.outError(out.str().c_str());
+}
+*/
+
+
+
+}
+}
+
+// handle outgoing packets the server would send to the client
+void PlayerbotAI::HandleBotOutgoingPacket(const WorldPacket& packet) {
+    switch(packet.GetOpcode()) {
+case SMSG_DUEL_WINNER: {
+m_bot->HandleEmoteCommand(EMOTE_ONESHOT_APPLAUD);
+return;
+}
+case SMSG_DUEL_COMPLETE: {
+m_ignoreAIUpdatesUntilTime = time(0) + 4;
+m_combatOrder = ORDERS_NONE;
+m_ScenarioType = SCENARIO_PVEEASY;
+m_bot->GetMotionMaster()->Clear(true);
+return;
+}
+case SMSG_DUEL_OUTOFBOUNDS: {
+m_bot->HandleEmoteCommand(EMOTE_ONESHOT_CHICKEN);
+return;
+}
+case SMSG_DUEL_REQUESTED: {
+m_ignoreAIUpdatesUntilTime = 0;
+WorldPacket p(packet);
+uint64 flagGuid; p >> flagGuid;
+uint64 playerGuid; p >> playerGuid;
+    Player* const pPlayer = ObjectAccessor::FindPlayer(playerGuid);
+    if (canObeyCommandFrom(*pPlayer)) {
+m_bot->GetMotionMaster()->Clear(true);
+WorldPacket* const packet = new WorldPacket(CMSG_DUEL_ACCEPTED, 8);
+*packet << flagGuid;
+m_bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+
+// follow target in casting range
+float angle = (float) (M_PI - (M_PI / urand(1,50))); // generates random float between 0 number less then 3.14
+float dist = (float) urand(4,10);
+m_bot->GetMotionMaster()->Clear(true);
+m_bot->GetMotionMaster()->MoveFollow(pPlayer, dist, angle);
+
+m_bot->SetSelection(playerGuid);
+m_ignoreAIUpdatesUntilTime = time(0) + 4;
+m_combatOrder = ORDERS_KILL;
+m_ScenarioType = SCENARIO_DUEL;
+    }
+return;
+}
+
+case SMSG_INVENTORY_CHANGE_FAILURE: {
+TellMaster("I can't use that.");
+return;
+}
+case SMSG_SPELL_FAILURE: {
+        WorldPacket p(packet);
+        uint64 casterGuid = extractGuid(p);
+        if (casterGuid != m_bot->GetGUID()) return;
+        uint32 spellId; p >> spellId;
+if (m_CurrentlyCastingSpellId == spellId) {
+            m_ignoreAIUpdatesUntilTime = time(0) + 1;
+            m_CurrentlyCastingSpellId = 0;
+}
+return;
+}
+
+// if a change in speed was detected for the master
+// make sure we have the same mount status
+case SMSG_FORCE_RUN_SPEED_CHANGE: {
+        WorldPacket p(packet);
+        uint64 guid = extractGuid(p);
+        if (guid != m_master->GetGUID()) return;
+        if (m_master->IsMounted() && ! m_bot->IsMounted()) {
+        Item* const pItem = m_bot->GetPlayerbotAI()->FindMount(300);
+        if (pItem) m_bot->GetPlayerbotAI()->UseItem(*pItem);
+        } else if (! m_master->IsMounted() && m_bot->IsMounted()) {
+            WorldPacket emptyPacket;
+m_bot->GetSession()->HandleDismountOpcode(emptyPacket);
+        }
+}
+
+// handle flying acknowledgement
+case SMSG_MOVE_SET_CAN_FLY: {
+        WorldPacket p(packet);
+        uint64 guid = extractGuid(p);
+        if (guid != m_bot->GetGUID()) return;
+        m_bot->AddUnitMovementFlag(MOVEMENTFLAG_FLYING2);
+    //m_bot->SetSpeed(MOVE_RUN, m_master->GetSpeed(MOVE_FLIGHT) +0.1f, true);
+        return;
+}
+
+// handle dismount flying acknowledgement
+case SMSG_MOVE_UNSET_CAN_FLY: {
+        WorldPacket p(packet);
+        uint64 guid = extractGuid(p);
+        if (guid != m_bot->GetGUID()) return;
+        m_bot->RemoveUnitMovementFlag(MOVEMENTFLAG_FLYING2);
+            //m_bot->SetSpeed(MOVE_RUN,m_master->GetSpeedRate(MOVE_RUN),true);
+        return;
+}
+
+// If the leader role was given to the bot automatically give it to the master
+        // if the master is in the group, otherwise leave group
+case SMSG_GROUP_SET_LEADER: {
+WorldPacket p(packet);
+std::string name; p >> name;
+if (m_bot->GetGroup() && name == m_bot->GetName()) {
+if (m_bot->GetGroup()->IsMember(m_master->GetGUID())) {
+p.resize(8);
+            p << m_master->GetGUID();
+m_bot->GetSession()->HandleGroupSetLeaderOpcode(p);
+} else {
+p.clear(); // not really needed
+m_bot->GetSession()->HandleGroupLeaveOpcode(p); // packet not used
+}
+}
+return;
+}
+
+// If the master leaves the group, then the bot leaves too
+case SMSG_PARTY_COMMAND_RESULT: {
+WorldPacket p(packet);
+uint32 operation; p >> operation;
+std::string member; p >> member;
+uint32 result; p >> result;
+p.clear();
+if (operation == PARTY_OP_LEAVE) {
+if (member == m_master->GetName())
+m_bot->GetSession()->HandleGroupLeaveOpcode(p); // packet not used
+}
+return;
+}
+
+// Handle Group invites (auto accept if master is in group, otherwise decline & send message
+case SMSG_GROUP_INVITE: {
+if (m_bot->GetGroupInvite()) {
+const Group* const grp = m_bot->GetGroupInvite();
+if (! grp) return;
+Player* const inviter = objmgr.GetPlayer(grp->GetLeaderGUID());
+if (! inviter) return;
+WorldPacket p;
+if (! canObeyCommandFrom(*inviter)) {
+std::string buf = "I can't accept your invite unless you first invite my master ";
+buf += m_master->GetName();
+buf += ".";
+SendWhisper(buf, *inviter);
+            m_bot->GetSession()->HandleGroupDeclineOpcode(p); // packet not used
+} else
+m_bot->GetSession()->HandleGroupAcceptOpcode(p);  // packet not used
+}
+return;
+}
+
+// Handle when another player opens the trade window with the bot
+// also sends list of tradable items bot can trade if bot is allowed to obey commands from
+        case SMSG_TRADE_STATUS: {
+        if (m_bot->GetTrader() == NULL) break;
+WorldPacket p(packet);
+        uint32 status; p >> status;
+        p.clear();
+
+            //4 == TRADE_STATUS_TRADE_ACCEPT
+            if (status == 4) {
+            m_bot->GetSession()->HandleAcceptTradeOpcode(p); // packet not used
+            }
+
+            //1 == TRADE_STATUS_BEGIN_TRADE
+            else if (status == 1) {
+            m_bot->GetSession()->HandleBeginTradeOpcode(p); // packet not used
+
+            if (! canObeyCommandFrom(*(m_bot->GetTrader()))) {
+            SendWhisper("I'm not allowed to trade you any of my items, but you are free to give me money or items.", *(m_bot->GetTrader()));
+            return;
+            }
+
+            // list out items available for trade
+        std::ostringstream out;
+
+        // list out items in main backpack
+        for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++) {
+        const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+if (pItem && pItem->CanBeTraded())
+{
+const ItemPrototype* const pItemProto = pItem->GetProto();
+std::string name = pItemProto->Name1;
+
+out << " |cffffffff|Hitem:" << pItemProto->ItemId << ":0:0:0:0:0:0:0" << "|h[" << name << "]|h|r";
+if (pItem->GetCount() > 1)
+out << "x" << pItem->GetCount() << ' ';
+}
+        }
+        // list out items in other removable backpacks
+        for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag) {
+        for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot) {
+        const Item* const pItem = m_bot->GetItemByPos(bag, slot);
+        if (pItem && pItem->CanBeTraded())
+        {
+        const ItemPrototype* const pItemProto = pItem->GetProto();
+        const std::string name = pItemProto->Name1;
+
+        // item link format: http://www.wowwiki.com/ItemString
+// itemId, enchantId, jewelId1, jewelId2, jewelId3, jewelId4, suffixId, uniqueId
+        out << " |cffffffff|Hitem:" << pItemProto->ItemId << ":0:0:0:0:0:0:0" << "|h[" << name << "]|h|r";
+        if (pItem->GetCount() > 1)
+        out << "x" << pItem->GetCount() << ' ';
+        }
+        }
+        }
+        }
+
+        // calculate how much money bot has
+        uint32 copper = m_bot->GetMoney();
+        uint32 gold = uint32(copper / 10000);
+        copper -= (gold * 10000);
+        uint32 silver = uint32(copper / 100);
+        copper -= (silver * 100);
+
+        // send bot the message
+        std::ostringstream whisper;
+        whisper << "I have |cff00ff00" << gold
+<< "|r|cfffffc00g|r|cff00ff00" << silver
+<< "|r|cffcdcdcds|r|cff00ff00" << copper
+<< "|r|cffffd333c|r" << " and the following items:";
+        SendWhisper(whisper.str().c_str(), *(m_bot->GetTrader()));
+        ChatHandler ch(m_bot->GetTrader());
+        ch.SendSysMessage(out.str().c_str());
+            }
+            return;
+        }
+
+        case SMSG_SPELL_GO: {
+        WorldPacket p(packet);
+        uint64 castItemGuid = extractGuid(p);
+        uint64 casterGuid = extractGuid(p);
+        if (casterGuid != m_bot->GetGUID()) return;
+
+        uint32 spellId; p >> spellId;
+        uint16 castFlags; p >> castFlags;
+        uint32 msTime; p >> msTime;
+        uint8 numHit; p >> numHit;
+
+if (m_CurrentlyCastingSpellId == spellId) {
+
+    Spell* const pSpell = m_bot->FindCurrentSpellBySpellId(spellId);
+    if (! pSpell) return;
+
+    if (pSpell->IsChannelActive() || pSpell->IsAutoRepeat())
+            m_ignoreAIUpdatesUntilTime = time(0) + (GetSpellDuration(pSpell->m_spellInfo) / 1000) + 1;
+    else if (pSpell->IsAutoRepeat())
+    	m_ignoreAIUpdatesUntilTime = time(0) + 6;
+    else {
+    	m_ignoreAIUpdatesUntilTime = time(0) + 1;
+    	m_CurrentlyCastingSpellId = 0;
+    }
+}
+
+    return;
+        }
+
+        /*
+        case SMSG_MONSTER_MOVE:
+        case SMSG_UPDATE_WORLD_STATE:
+        case SMSG_COMPRESSED_UPDATE_OBJECT:
+        case MSG_MOVE_SET_FACING:
+        case MSG_MOVE_STOP:
+        case MSG_MOVE_HEARTBEAT:
+        case MSG_MOVE_STOP_STRAFE:
+        case MSG_MOVE_START_STRAFE_LEFT:
+        case SMSG_UPDATE_OBJECT:
+        case MSG_MOVE_START_FORWARD:
+        return;
+
+        default:
+        const char* oc = LookupOpcodeName(packet.GetOpcode());
+        TellMaster(oc);
+        sLog.outError("opcode: %s", oc);
+*/
+
+    }
+}
+
+uint8 PlayerbotAI::GetHealthPercent(const Unit& target) const {
+return (static_cast<float>(target.GetHealth()) / target.GetMaxHealth()) * 100;
+}
+uint8 PlayerbotAI::GetHealthPercent() const {
+return GetHealthPercent(*m_bot);
+}
+uint8 PlayerbotAI::GetManaPercent(const Unit& target) const {
+return (static_cast<float>(target.GetPower(POWER_MANA)) / target.GetMaxPower(POWER_MANA)) * 100;
+}
+uint8 PlayerbotAI::GetManaPercent() const {
+return GetManaPercent(*m_bot);
+}
+uint8 PlayerbotAI::GetBaseManaPercent(const Unit& target) const {
+if (target.GetPower(POWER_MANA) >= target.GetCreateMana()) {
+return (100);
+}
+else {
+return (static_cast<float>(target.GetPower(POWER_MANA)) / target.GetMaxPower(POWER_MANA)) * 100;
+}
+}
+uint8 PlayerbotAI::GetBaseManaPercent() const {
+return GetBaseManaPercent(*m_bot);
+}
+uint8 PlayerbotAI::GetRageAmount(const Unit& target) const {
+return (static_cast<float>(target.GetPower(POWER_RAGE)));
+}
+uint8 PlayerbotAI::GetRageAmount() const {
+return GetRageAmount(*m_bot);
+}
+uint8 PlayerbotAI::GetEnergyAmount(const Unit& target) const {
+return (static_cast<float>(target.GetPower(POWER_ENERGY)));
+}
+uint8 PlayerbotAI::GetEnergyAmount() const {
+return GetEnergyAmount(*m_bot);
+}
+uint8 PlayerbotAI::GetRunicPower(const Unit& target) const {
+return (static_cast<float>(target.GetPower(POWER_RUNIC_POWER)));
+}
+uint8 PlayerbotAI::GetRunicPower() const {
+return GetRunicPower(*m_bot);
+}
+
+typedef std::pair<uint32, uint8> spellEffectPair;
+typedef std::multimap< spellEffectPair, Aura*> AuraMap;
+
+bool PlayerbotAI::HasAura(uint32 spellId, const Unit& player) const {
+for (AuraMap::const_iterator iter = player.GetAuras().begin(); iter != player.GetAuras().end(); ++iter) {
+if (iter->second->GetId() == spellId)
+return true;
+}
+return false;
+}
+bool PlayerbotAI::HasAura(const char* spellName) const {
+return HasAura(spellName, *m_bot);
+}
+bool PlayerbotAI::HasAura(const char* spellName, const Unit& player) const {
+uint32 spellId = getSpellId(spellName);
+return (spellId) ? HasAura(spellId, player) : false;
+}
+
+// looks through all items / spells that bot could have to get a mount
+Item* PlayerbotAI::FindMount(uint32 matchingRidingSkill) const {
+// list out items in main backpack
+
+Item* partialMatch = NULL;
+
+for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++) {
+Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+if (pItem) {
+const ItemPrototype* const pItemProto = pItem->GetProto();
+if (! pItemProto || ! m_bot->CanUseItem(pItemProto) ||
+pItemProto->RequiredSkill != SKILL_RIDING) continue;
+if (pItemProto->RequiredSkillRank == matchingRidingSkill) return pItem;
+else if (! partialMatch ||
+(partialMatch && partialMatch->GetProto()->RequiredSkillRank <
+     pItemProto->RequiredSkillRank))
+partialMatch = pItem;
+}
+}
+
+// list out items in other removable backpacks
+for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) {
+const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+if (pBag) {
+for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot) {
+Item* const pItem = m_bot->GetItemByPos(bag, slot);
+if (pItem) {
+const ItemPrototype* const pItemProto = pItem->GetProto();
+if (! pItemProto || ! m_bot->CanUseItem(pItemProto) ||
+pItemProto->RequiredSkill != SKILL_RIDING) continue;
+if (pItemProto->RequiredSkillRank == matchingRidingSkill) return pItem;
+else if (! partialMatch ||
+(partialMatch && partialMatch->GetProto()->RequiredSkillRank <
+     pItemProto->RequiredSkillRank))
+partialMatch = pItem;
+}
+}
+}
+}
+return partialMatch;
+}
+
+Item* PlayerbotAI::FindFood() const {
+// list out items in main backpack
+for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++) {
+Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+if (pItem) {
+const ItemPrototype* const pItemProto = pItem->GetProto();
+if (! pItemProto || ! m_bot->CanUseItem(pItemProto)) continue;
+            if(pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+               pItemProto->SubClass==ITEM_SUBCLASS_FOOD) {
+
+            // if is FOOD
+            if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_FOOD)
+            return pItem;
+            }
+}
+}
+// list out items in other removable backpacks
+for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) {
+const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+if (pBag) {
+for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot) {
+Item* const pItem = m_bot->GetItemByPos(bag, slot);
+if (pItem) {
+const ItemPrototype* const pItemProto = pItem->GetProto();
+if (! pItemProto || ! m_bot->CanUseItem(pItemProto)) continue;
+            if(pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+               pItemProto->SubClass==ITEM_SUBCLASS_FOOD) {
+            // if is FOOD
+            if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_FOOD)
+            return pItem;
+            }
+}
+}
+}
+}
+return NULL;
+}
+
+Item* PlayerbotAI::FindDrink() const {
+// list out items in main backpack
+for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++) {
+Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+if (pItem) {
+const ItemPrototype* const pItemProto = pItem->GetProto();
+if (! pItemProto || ! m_bot->CanUseItem(pItemProto)) continue;
+            if(pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+               pItemProto->SubClass==ITEM_SUBCLASS_FOOD) {
+                if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK)
+            return pItem;
+            }
+}
+}
+// list out items in other removable backpacks
+for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) {
+const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+if (pBag) {
+for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot) {
+Item* const pItem = m_bot->GetItemByPos(bag, slot);
+if (pItem) {
+const ItemPrototype* const pItemProto = pItem->GetProto();
+if (! pItemProto || ! m_bot->CanUseItem(pItemProto)) continue;
+            if(pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+               pItemProto->SubClass==ITEM_SUBCLASS_FOOD) {
+            // if is WATER
+            if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK)
+            return pItem;
+            }
+}
+}
+}
+}
+return NULL;
+}
+
+Item* PlayerbotAI::FindBandage() const {
+// list out items in main backpack
+for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++) {
+Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+if (pItem) {
+const ItemPrototype* const pItemProto = pItem->GetProto();
+if (! pItemProto || ! m_bot->CanUseItem(pItemProto)) continue;
+            if(pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+               pItemProto->SubClass==ITEM_SUBCLASS_BANDAGE) {
+            return pItem;
+            }
+}
+}
+// list out items in other removable backpacks
+for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) {
+const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+if (pBag) {
+for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot) {
+Item* const pItem = m_bot->GetItemByPos(bag, slot);
+if (pItem) {
+const ItemPrototype* const pItemProto = pItem->GetProto();
+if (! pItemProto || ! m_bot->CanUseItem(pItemProto)) continue;
+            if(pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+               pItemProto->SubClass==ITEM_SUBCLASS_BANDAGE) {
+            return pItem;
+            }
+}
+}
+}
+}
+return NULL;
+}
+//Find Poison ...Natsukawa
+Item* PlayerbotAI::FindPoison() const {
+// list out items in main backpack
+for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++) {
+Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+if (pItem) {
+const ItemPrototype* const pItemProto = pItem->GetProto();
+if (! pItemProto || ! m_bot->CanUseItem(pItemProto)) continue;
+            if(pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+               pItemProto->SubClass==6) {
+            return pItem;
+            }
+}
+}
+// list out items in other removable backpacks
+for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) {
+const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+if (pBag) {
+for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot) {
+Item* const pItem = m_bot->GetItemByPos(bag, slot);
+if (pItem) {
+const ItemPrototype* const pItemProto = pItem->GetProto();
+if (! pItemProto || ! m_bot->CanUseItem(pItemProto)) continue;
+            if(pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+               pItemProto->SubClass==6) {
+            	return pItem;
+            }
+}
+}
+}
+}
+return NULL;
+}
+
+void PlayerbotAI::InterruptCurrentCastingSpell() {
+TellMaster("I'm interrupting my current spell!");
+WorldPacket* const packet = new WorldPacket(CMSG_CANCEL_CAST,4);
+*packet << m_CurrentlyCastingSpellId;
+m_CurrentlyCastingSpellId = 0;
+m_bot->GetSession()->QueuePacket(packet);
+}
+
+void PlayerbotAI::Feast() {
+// stand up if we are done feasting
+if (!(m_bot->GetHealth() < m_bot->GetMaxHealth() ||
+ (m_bot->getPowerType() == POWER_MANA &&
+  m_bot->GetPower(POWER_MANA) < m_bot->GetMaxPower(POWER_MANA)))) {
+m_bot->SetStandState(PLAYER_STATE_NONE);
+return;
+}
+
+// wait 3 seconds before checking if we need to drink more or eat more
+time_t currentTime = time(0);
+m_ignoreAIUpdatesUntilTime = currentTime + 3;
+
+// should we drink another
+if (m_bot->getPowerType() == POWER_MANA && currentTime > m_TimeDoneDrinking
+&& ((static_cast<float>(m_bot->GetPower(POWER_MANA)) / m_bot->GetMaxPower(POWER_MANA)) < 0.8)) {
+Item* pItem = FindDrink();
+if (pItem != NULL) {
+UseItem(*pItem);
+m_TimeDoneDrinking = currentTime + 30;
+return;
+}
+TellMaster("I need water.");
+}
+
+// should we eat another
+if (currentTime > m_TimeDoneEating && ((static_cast<float>(m_bot->GetHealth()) / m_bot->GetMaxHealth()) < 0.8)) {
+Item* pItem = FindFood();
+if (pItem != NULL) {
+//TellMaster("eating now...");
+UseItem(*pItem);
+m_TimeDoneEating = currentTime + 30;
+return;
+}
+TellMaster("I need food.");
+}
+
+// if we are no longer eating or drinking
+// because we are out of items or we are above 80% in both stats
+if (currentTime > m_TimeDoneEating && currentTime > m_TimeDoneDrinking) {
+TellMaster("done feasting!");
+m_bot->SetStandState(PLAYER_STATE_NONE);
+}
+}
+
+// intelligently sets a reasonable combat order for this bot
+// based on its class / level / etc
+void PlayerbotAI::GetCombatOrders() {
+Unit* thingToAttack = m_master->getAttackerForHelper();
+if (! thingToAttack) return;
+
+// if thing to attack is in a duel, then ignore and don't call updateAI for 6 seconds
+// this method never gets called when the bot is in a duel and this code
+// prevents bot from helping
+if (thingToAttack->GetTypeId() == TYPEID_PLAYER && dynamic_cast<Player*>(thingToAttack)->duel) {
+m_ignoreAIUpdatesUntilTime = time(0) + 6;
+return;
+}
+
+m_bot->SetSelection(thingToAttack->GetGUID());
+m_ignoreAIUpdatesUntilTime = time(0) + 1;
+m_combatOrder = ORDERS_KILL;
+
+if (m_bot->getStandState() != PLAYER_STATE_NONE)
+m_bot->SetStandState(PLAYER_STATE_NONE);
+
+m_bot->Attack(thingToAttack, true);
+
+m_bot->GetMotionMaster()->Clear(true);
+
+// follow target in casting range - I commented out the priest & mage classes because of strange behavior - feel free to experiment
+switch(m_bot->getClass()) {
+case CLASS_PRIEST:
+break;
+case CLASS_MAGE:
+break;
+case CLASS_SHAMAN:
+break;
+case CLASS_WARLOCK:
+break;
+case CLASS_DRUID: {
+float angle = (float) (M_PI - (M_PI / urand(1,50))); // generates random float between 0 number less then 3.14
+float dist = (float) urand(4,10);
+m_bot->GetMotionMaster()->Clear(true);
+m_bot->GetMotionMaster()->MoveFollow(thingToAttack, dist, angle);
+break;
+}
+default:
+m_bot->GetMotionMaster()->MoveChase(thingToAttack);
+}
+
+return;
+}
+
+void PlayerbotAI::DoNextCombatManeuver() {
+Unit* const pTarget = ObjectAccessor::GetUnit(*m_bot, m_bot->GetSelection());
+
+// if current order doesn't make sense anymore
+// clear our orders so we can get orders in next update
+if (!pTarget || pTarget->isDead() || !pTarget->IsInWorld() || !m_bot->IsHostileTo(pTarget)) {
+m_combatOrder = ORDERS_NONE;
+m_bot->SetSelection(0);
+m_bot->GetMotionMaster()->Clear(true);
+return;
+}
+
+switch(m_bot->getClass()) {
+
+case CLASS_PRIEST:
+if (GetClassAI()) {
+(GetClassAI())->DoNextCombatManeuver(pTarget);
+} 
+/*
+(HasAura("scream",*pTarget) && GetHealthPercent() < 60 && CastSpell("greater heal")) ||
+CastSpell("pain") ||
+(GetHealthPercent() < 80 && CastSpell("renew")) ||
+(m_bot->GetDistance(pTarget) <= 5 && CastSpell("scream")) ||
+CastSpell("mind blast") ||
+(GetHealthPercent() < 20 && CastSpell("flash heal")) ||
+CastSpell("smite");
+*/
+break;
+
+case CLASS_MAGE:
+if (GetClassAI()) {
+(GetClassAI())->DoNextCombatManeuver(pTarget);
+}
+break;
+
+case CLASS_WARLOCK:
+if (GetClassAI()) {
+(GetClassAI())->DoNextCombatManeuver(pTarget);
+}
+break;
+
+case CLASS_WARRIOR:
+if (GetClassAI()) {
+(GetClassAI())->DoNextCombatManeuver(pTarget);
+}
+break;
+
+case CLASS_SHAMAN:
+if (GetClassAI()) {
+(GetClassAI())->DoNextCombatManeuver(pTarget);
+}
+break;
+
+case CLASS_PALADIN:
+if (GetClassAI()) {
+(GetClassAI())->DoNextCombatManeuver(pTarget);
+}
+break;
+
+case CLASS_ROGUE:
+if (GetClassAI()) {
+(GetClassAI())->DoNextCombatManeuver(pTarget);
+}
+break;
+
+case CLASS_DRUID:
+if (GetClassAI()) {
+(GetClassAI())->DoNextCombatManeuver(pTarget);
+}
+break;
+
+case CLASS_HUNTER:
+if (GetClassAI()) {
+(GetClassAI())->DoNextCombatManeuver(pTarget);
+}
+break;
+
+case CLASS_DEATH_KNIGHT:
+if (GetClassAI()) {
+(GetClassAI())->DoNextCombatManeuver(pTarget);
+}
+break;
+
+}
+}
+
+// this is where the AI should go
+//GetRandomContactPoint
+//GetPower, GetMaxPower
+// HasSpellCooldown
+// IsAffectedBySpellmod
+// isMoving
+// hasUnitState(FLAG) FLAG like: UNIT_STAT_ROOT, UNIT_STAT_CONFUSED, UNIT_STAT_STUNNED
+// hasAuraType
+
+void PlayerbotAI::UpdateAI(const uint32 p_time) {
+time_t currentTime = time(0);
+if (currentTime < m_ignoreAIUpdatesUntilTime || m_bot->IsBeingTeleported() || m_bot->GetTrader()) return;
+
+// default updates occur every two seconds
+m_ignoreAIUpdatesUntilTime = time(0) + 2;
+
+// if we are casting a spell then interrupt it
+// make sure any actions that cast a spell set a proper m_ignoreAIUpdatesUntilTime!
+Spell* const pSpell = GetCurrentSpell();
+if (pSpell && !(pSpell->IsChannelActive() || pSpell->IsAutoRepeat()))
+InterruptCurrentCastingSpell();
+
+// direct cast command from master
+else if (m_spellIdCommand != 0) {
+    Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, m_targetGuidCommand);
+    if (pTarget != NULL)
+    CastSpell(m_spellIdCommand, *pTarget);
+    m_spellIdCommand = 0;
+    m_targetGuidCommand = 0;
+}
+
+// handle combat
+else if (m_combatOrder != ORDERS_NONE)
+DoNextCombatManeuver();
+
+// if master is in combat and bot is not, automatically assist master
+// NOTE: combat orders are also set via incoming packets to bot or outgoing packets from master
+//	else if (m_master->isInCombat() && ! m_bot->isInCombat())
+else if (m_master->isInCombat())
+GetCombatOrders();
+/*
+// are we sitting, if so feast if possible
+else if (m_bot->getStandState() == PLAYER_STATE_SIT)
+Feast();
+*/
+// if commanded to follow master and not already following master then follow master
+else if (!m_bot->isInCombat() && m_IsFollowingMaster &&
+m_bot->GetMotionMaster()->GetCurrentMovementGeneratorType() == IDLE_MOTION_TYPE)
+Follow(* m_master);
+
+// do class specific non combat actions
+else if (GetClassAI()) {
+(GetClassAI())->DoNonCombatActions();
+} 
+}
+
+Spell* PlayerbotAI::GetCurrentSpell() const {
+if (m_CurrentlyCastingSpellId == 0) return NULL;
+Spell* const pSpell = m_bot->FindCurrentSpellBySpellId(m_CurrentlyCastingSpellId);
+return pSpell;
+}
+
+void PlayerbotAI::TellMaster(const std::string& text) {
+SendWhisper(text, *m_master);
+}
+
+void PlayerbotAI::SendWhisper(const std::string& text, Player& player) {
+WorldPacket data(SMSG_MESSAGECHAT, 200);
+m_bot->BuildPlayerChat(&data, CHAT_MSG_REPLY, text, LANG_UNIVERSAL);
+player.GetSession()->SendPacket(&data);
+}
+
+bool PlayerbotAI::canObeyCommandFrom(const Player& player) const {
+return player.GetSession()->GetAccountId() == m_master->GetSession()->GetAccountId();
+}
+
+bool PlayerbotAI::CastSpell(const char* args) {
+uint32 spellId = getSpellId(args);
+return (spellId) ? CastSpell(spellId) : false;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId, Unit& target) {
+uint64 oldSel = m_bot->GetSelection();
+m_bot->SetSelection(target.GetGUID());
+bool rv = CastSpell(spellId);
+m_bot->SetSelection(oldSel);
+return rv;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId) {
+
+// see Creature.cpp 1738 for reference
+// don't allow bot to cast damage spells on friends
+    const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (! pSpellInfo) {
+    TellMaster("missing spell entry in CastSpell.");
+    return false;
+    }
+
+// set target
+uint64 targetGUID = m_bot->GetSelection();
+Unit* pTarget = ObjectAccessor::GetUnit(*m_bot, m_bot->GetSelection());
+    if (IsPositiveSpell(spellId)) {
+    if (pTarget && ! m_bot->IsFriendlyTo(pTarget))
+    pTarget = m_bot;
+    }
+    else {
+    if (pTarget && m_bot->IsFriendlyTo(pTarget))
+    return false;
+
+    // search for Creature::reachWithSpellAttack to also see some examples of spell distance usage
+    if (! m_bot->isInFront(pTarget, 10)) {
+    m_bot->SetInFront(pTarget);
+    WorldPacket data;
+    m_bot->BuildHeartBeatMsg(&data);
+    m_bot->SendMessageToSet(&data,true);
+    }
+    }
+
+    if (HasAura(spellId, *pTarget)) return false;
+
+    m_bot->CastSpell(pTarget,pSpellInfo,false);
+
+    Spell* const pSpell = m_bot->FindCurrentSpellBySpellId(spellId);
+    if (! pSpell) return false;
+
+    m_CurrentlyCastingSpellId = spellId;
+// m_ignoreAIUpdatesUntilTime = time(0) + pSpell->GetCastTime() + 3;
+    m_ignoreAIUpdatesUntilTime = time(0) + 6;
+
+   // if this caused the caster to move (blink) update the position
+    // I think this is normally done on the client
+// this should be done on spell success
+/*
+    if (name == "Blink") {
+float x,y,z;
+m_bot->GetPosition(x,y,z);
+m_bot->GetNearPoint(m_bot, x, y, z, 1, 5, 0);
+m_bot->Relocate(x,y,z);
+WorldPacket data;
+m_bot->BuildHeartBeatMsg(&data);
+m_bot->SendMessageToSet(&data,true);
+    }
+    */
+
+return true;
+}
+
+// ChatHandler already implements some useful commands the master can call on bots
+// These commands are protected inside the ChatHandler class so this class provides access to the commands
+// we'd like to call on our bots
+class PlayerbotChatHandler : protected ChatHandler {
+    public:
+    explicit PlayerbotChatHandler(Player* pMasterPlayer) : ChatHandler(pMasterPlayer) {}
+
+    bool revive(const Player& botPlayer) {
+        return HandleReviveCommand(botPlayer.GetName());
+        }
+    bool teleport(const Player& botPlayer) {
+    return HandleNamegoCommand(botPlayer.GetName());
+    }
+    void sysmessage(const char *str) {
+    SendSysMessage(str);
+    }
+};
+
+// extracts all item ids in format below
+// I decided to roll my own extractor rather then use the one in ChatHandler
+// because this one works on a const string, and it handles multiple links
+// |color|linkType:key:something1:...:somethingN|h[name]|h|r
+void PlayerbotAI::extractItemIds(const std::string& text, std::list<uint32>& itemIds) const {
+uint8 pos = 0;
+while (true) {
+int i = text.find("Hitem:", pos);
+if (i == -1) break;
+pos = i + 6;
+int endPos = text.find(':', pos);
+if (endPos == -1) break;
+std::string idC = text.substr(pos, endPos - pos);
+uint32 id = atol(idC.c_str());
+pos = endPos;
+if (id) itemIds.push_back(id);
+}
+}
+
+// extracts currency in #g#s#c format
+uint32 PlayerbotAI::extractMoney(const std::string& text) const {
+// if user specified money in ##g##s##c format
+std::string acum = "";
+uint32 copper = 0;
+for (uint8 i=0; i < text.length(); i++) {
+if (text[i] == 'g') {
+copper += (atol(acum.c_str()) * 100 * 100);
+acum = "";
+} else if (text[i] == 'c') {
+copper += atol(acum.c_str());
+acum = "";
+} else if (text[i] == 's') {
+copper += (atol(acum.c_str()) * 100);
+acum = "";
+} else if (text[i] == ' ') {
+break;
+} else if (text[i] >= 48 && text[i] <= 57) {
+acum += text[i];
+} else {
+copper = 0;
+break;
+}
+}
+return copper;
+}
+
+// finds items in inventory and adds Item* to foundItemList
+// also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const {
+
+    // look for items in main bag
+for (uint8 slot=INVENTORY_SLOT_ITEM_START; itemIdSearchList.size() > 0 &&
+slot < INVENTORY_SLOT_ITEM_END; ++slot) {
+Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+if (!pItem) continue;
+for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it) {
+if (pItem->GetProto()->ItemId != *it) continue;
+foundItemList.push_back(pItem);
+itemIdSearchList.erase(it);
+break;
+}
+}
+
+// for all for items in other bags
+for (uint8 bag = INVENTORY_SLOT_BAG_START; itemIdSearchList.size() > 0 &&
+bag < INVENTORY_SLOT_BAG_END; ++bag) {
+Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+if (! pBag) continue;
+for (uint8 slot = 0; itemIdSearchList.size() > 0 &&
+slot < pBag->GetBagSize(); ++slot) {
+Item* const pItem = m_bot->GetItemByPos(bag, slot);
+if (!pItem) continue;
+for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it) {
+if (pItem->GetProto()->ItemId != *it) continue;
+foundItemList.push_back(pItem);
+itemIdSearchList.erase(it);
+break;
+}
+}
+}
+}
+
+// submits packet to use an item
+void PlayerbotAI::UseItem(Item& item) {
+uint8 bagIndex = item.GetBagSlot();
+uint8 slot = item.GetSlot();
+uint8 cast_count = 1;
+uint32 spellid = 0;		// only used in combat
+uint64 item_guid = item.GetGUID();
+uint32 glyphIndex = 0;	// ??
+uint8 unk_flags = 0;	// not 0x02
+
+// create target data
+// note other targets are possible but not supported at the moment
+// see SpellCastTargets::read in Spell.cpp to see other options
+// for setting target
+
+uint32 target = TARGET_FLAG_SELF;
+
+WorldPacket* const packet = new WorldPacket(CMSG_USE_ITEM, 1+1+1+4+8+4+1);
+*packet << bagIndex << slot << cast_count << spellid << item_guid << glyphIndex << unk_flags << target;
+m_bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+
+// certain items cause player to sit (food,drink)
+// tell bot to stop following if this is the case
+// (doesn't work since we queued the packet!)
+// maybe its not needed???
+//if (! m_bot->IsStandState())
+//	m_bot->GetMotionMaster()->Clear();
+}
+
+// submits packet to use an item
+void PlayerbotAI::EquipItem(Item& item) {
+uint8 bagIndex = item.GetBagSlot();
+uint8 slot = item.GetSlot();
+
+WorldPacket* const packet = new WorldPacket(CMSG_AUTOEQUIP_ITEM,2);
+*packet << bagIndex << slot;
+m_bot->GetSession()->QueuePacket(packet);
+}
+
+// submits packet to trade an item (trade window must already be open)
+bool PlayerbotAI::TradeItem(const Item& item) {
+if (! m_bot->GetTrader() || item.IsInTrade() || ! item.CanBeTraded())
+return false;
+for (uint8 i=0; i < TRADE_SLOT_TRADED_COUNT; ++i) {
+if (m_bot->GetItemPosByTradeSlot(i) == NULL_SLOT) {
+WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_ITEM, 3);
+*packet << (uint8) i << (uint8) item.GetBagSlot() << (uint8) item.GetSlot();
+m_bot->GetSession()->QueuePacket(packet);
+return true;
+}
+}
+return false;
+}
+
+// submits packet to trade copper (trade window must be open)
+bool PlayerbotAI::TradeCopper(uint32 copper) {
+if (copper > 0) {
+WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_GOLD, 4);
+*packet << copper;
+m_bot->GetSession()->QueuePacket(packet);
+return true;
+}
+return false;
+}
+
+void PlayerbotAI::Stay() {
+m_IsFollowingMaster = false;
+m_bot->GetMotionMaster()->Clear(true);
+m_bot->HandleEmoteCommand(EMOTE_ONESHOT_SALUTE);
+}
+
+bool PlayerbotAI::Follow(Player& player) {
+if (m_master->IsBeingTeleported()) return false;
+m_IsFollowingMaster = true;
+
+if (! m_bot->IsStandState())
+m_bot->SetStandState(PLAYER_STATE_NONE);
+
+if (! m_bot->isInCombat()) {
+// if bot is dead and master is alive, revive bot
+if (m_master->isAlive() && ! m_bot->isAlive()) {
+    m_ignoreAIUpdatesUntilTime = time(0) + 6;
+PlayerbotChatHandler ch(m_master);
+if (! ch.revive(*m_bot)) {
+ch.sysmessage(".. could not be revived ..");
+return false;
+}
+}
+
+// if bot has strayed too far from the master, teleport bot
+if (m_bot->GetMapId() != player.GetMapId() ||
+m_bot->GetZoneId() != player.GetZoneId() ||
+(abs(abs(m_bot->GetPositionX()) - abs(player.GetPositionX())) > 50) ||
+(abs(abs(m_bot->GetPositionY()) - abs(player.GetPositionY())) > 50) ||
+(abs(abs(m_bot->GetPositionZ()) - abs(player.GetPositionZ())) > 50)) {
+    m_ignoreAIUpdatesUntilTime = time(0) + 6;
+PlayerbotChatHandler ch(m_master);
+if (! ch.teleport(*m_bot)) {
+ch.sysmessage(".. could not be teleported ..");
+return false;
+}
+}
+}
+
+if (m_bot->isAlive()) {
+float angle = (float) (M_PI - (M_PI / urand(1,50))); // generates random float between 0 number less then 3.14
+float dist = (float) urand(1,9);
+m_bot->GetMotionMaster()->Clear(true);
+m_bot->GetMotionMaster()->MoveFollow(&player, dist, angle);
+return true;
+}
+return false;
+}
+
+// handle commands sent through chat channels
+void PlayerbotAI::HandleCommand(const std::string& text, Player& fromPlayer) {
+     // ignore any messages from Addons
+     if (text.find("X-Perl")!=std::wstring::npos) return;
+     if (text.find("HealBot")!=std::wstring::npos) return;
+     if (text.find("LOOT_OPENED")!=std::wstring::npos) return;
+     if (text.find("CTRA")!=std::wstring::npos) return;
+
+// if message is not from a player in the masters account auto reply and ignore
+if (! canObeyCommandFrom(fromPlayer)) {
+std::string msg = "I can't talk to you. Please speak to my master ";
+msg += m_master->GetName();
+SendWhisper(msg, fromPlayer);
+m_bot->HandleEmoteCommand(EMOTE_ONESHOT_NO);
+}
+
+// if in the middle of a trade, and player asks for an item/money
+else if (m_bot->GetTrader() && m_bot->GetTrader()->GetGUID() == fromPlayer.GetGUID()) {
+uint32 copper = extractMoney(text);
+if (copper > 0) TradeCopper(copper);
+
+std::list<uint32> itemIds;
+extractItemIds(text, itemIds);
+    if(itemIds.size() == 0)
+    SendWhisper("Show me what item you want by shift clicking the item in the chat window.", fromPlayer);
+    else {
+    std::list<Item*> itemList;
+    findItemsInInv(itemIds, itemList);
+    for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+    TradeItem(**it);
+    }
+}
+
+else if (text == "follow" || text == "come")
+Follow(*m_master);
+
+else if (text == "stay" || text == "stop")
+Stay();
+
+else if (text == "attack") {
+    uint64 attackOnGuid = fromPlayer.GetSelection();
+    if (attackOnGuid) {
+Unit* thingToAttack = ObjectAccessor::GetUnit(*m_bot, attackOnGuid);
+if (!m_bot->IsFriendlyTo(thingToAttack) && m_bot->IsWithinLOSInMap(thingToAttack)) {
+m_bot->GetMotionMaster()->Clear(true);
+m_combatOrder = ORDERS_KILL;
+m_bot->SetSelection(thingToAttack->GetGUID());
+m_bot->Attack(thingToAttack, true);
+m_bot->GetMotionMaster()->MoveChase(thingToAttack);
+m_ignoreAIUpdatesUntilTime = time(0) + 6;
+}
+}
+else {
+TellMaster("No target is selected.");
+m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+}
+}
+
+// handle cast command
+else if (text.size() > 2 && text.substr(0,2) == "c " ||
+ text.size() > 5 && text.substr(0,5) == "cast ") {
+std::string spellStr = text.substr(text.find(" ") + 1);
+    uint32 spellId = (uint32)atol(spellStr.c_str());
+
+    // try and get spell ID by name
+if (spellId == 0)
+spellId = getSpellId(spellStr.c_str());
+
+    uint64 castOnGuid = fromPlayer.GetSelection();
+    if (spellId != 0 && castOnGuid != 0) {
+    	m_spellIdCommand = spellId;
+    	m_targetGuidCommand = castOnGuid;
+    }
+}
+
+// use items
+else if (text.size() > 2 && text.substr(0,2) == "u " ||
+ text.size() > 4 && text.substr(0,4) == "use ") {
+std::list<uint32> itemIds;
+std::list<Item*> itemList;
+extractItemIds(text, itemIds);
+findItemsInInv(itemIds, itemList);
+for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+UseItem(**it);
+}
+
+// equip items
+else if (text.size() > 2 && text.substr(0,2) == "e " ||
+ text.size() > 6 && text.substr(0,6) == "equip ") {
+std::list<uint32> itemIds;
+std::list<Item*> itemList;
+extractItemIds(text, itemIds);
+findItemsInInv(itemIds, itemList);
+for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+EquipItem(**it);
+}
+
+else if (text == "spells") {
+
+int loc = m_master->GetSession()->GetSessionDbcLocale();
+
+std::ostringstream posOut;
+std::ostringstream negOut;
+
+const std::string ignoreList = ",Opening,Closing,Stuck,Remove Insignia,Opening - No Text,Grovel,Duel,Honorless Target,";
+std::string alreadySeenList = ",";
+
+for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr) {
+const uint32 spellId = itr->first;
+
+if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || IsPassiveSpell(spellId))
+continue;
+
+const SpellEntry* const pSpellInfo = sSpellStore.LookupEntry(spellId);
+if (! pSpellInfo)
+continue;
+
+//|| name.find("Teleport") != -1
+
+std::string comp = ",";
+comp.append(pSpellInfo->SpellName[loc]);
+comp.append(",");
+
+if (!(ignoreList.find(comp) == std::string::npos &&
+  alreadySeenList.find(comp) == std::string::npos))
+continue;
+
+alreadySeenList += pSpellInfo->SpellName[loc];
+alreadySeenList += ",";
+
+if (IsPositiveSpell(spellId))
+posOut << " |cffffffff|Hspell:" << spellId << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
+else
+negOut << " |cffffffff|Hspell:" << spellId << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
+}
+
+ChatHandler ch(&fromPlayer);
+SendWhisper("here's my non-attack spells:", fromPlayer);
+ch.SendSysMessage(posOut.str().c_str());
+SendWhisper("and here's my attack spells:", fromPlayer);
+ch.SendSysMessage(negOut.str().c_str());
+}
+
+else {
+std::string msg = "What? follow, stay, (c)ast <spellname>, spells, (e)quip, (u)se.";
+SendWhisper(msg, fromPlayer);
+m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+}
+}
diff --git a/src/game/PlayerbotAI.h b/src/game/PlayerbotAI.h
new file mode
--- /dev/null
+++ b/src/game/PlayerbotAI.h
@@ -0,0 +1,166 @@
+#ifndef _PLAYERBOTAI_H
+#define _PLAYERBOTAI_H
+
+#include "Common.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+class PlayerbotClassAI;
+
+enum ScenarioType {
+SCENARIO_PVEEASY,
+SCENARIO_PVEHARD,
+SCENARIO_DUEL,
+SCENARIO_PVPEASY,
+SCENARIO_PVPHARD
+};
+
+class MANGOS_DLL_SPEC PlayerbotAI {
+    public:
+    // ******* Stuff the outside world calls ****************************
+        PlayerbotAI(Player* const master, Player* const bot);
+        virtual ~PlayerbotAI();
+
+        // This is called from Unit.cpp and is called every second (I think)
+        void UpdateAI(const uint32 p_time);
+
+        // This is called from ChatHandler.cpp when there is an incoming message to the bot
+        // from a whisper or from the party channel
+        void HandleCommand(const std::string& text, Player& fromPlayer);
+
+        // This is called by WorldSession.pm
+        // It provides a view of packets normally sent to the client.
+        // Since there is no client at the other end, the packets are dropped of course.
+        // For a list of opcodes that can be caught see Opcodes.cpp (SMSG_* opcodes only)
+        void HandleBotOutgoingPacket(const WorldPacket& packet);
+
+        // This is called whenever the master sends a packet to the server.
+        // These packets can be viewed, but not edited.
+        // It allows bot creators to craft AI in response to a master's actions.
+        // For a list of opcodes that can be caught see Opcodes.cpp (CMSG_* opcodes only)
+        // Notice: that this is static which means it is called once for all bots of the master.
+        static void HandleMasterIncomingPacket(const WorldPacket& packet, WorldSession& masterSession);
+        static void HandleMasterOutgoingPacket(const WorldPacket& packet, WorldSession& masterSession);
+
+// Returns what kind of situation we are in so the ai can react accordingly
+ScenarioType GetScenarioType() {return m_ScenarioType;}
+
+PlayerbotClassAI* GetClassAI() {return m_classAI;}
+
+    //protected:
+
+    // ******* Utilities ***************************************************
+
+    // finds spell ID for matching substring args
+        // in priority of full text match, spells not taking reagents, and highest rank
+    uint32 getSpellId(const char* args) const;
+
+        // extracts item ids from links
+        void extractItemIds(const std::string& text, std::list<uint32>& itemIds) const;
+
+        // extracts currency from a string as #g#s#c and returns the total in copper
+        uint32 extractMoney(const std::string& text) const;
+
+        // finds items in bots inventory and adds them to foundItemList, removes found items from itemIdSearchList
+        void findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+
+        // currently bots only obey commands from the master
+        bool canObeyCommandFrom(const Player& player) const;
+
+        // get current casting spell (will return NULL if no spell!)
+        Spell* GetCurrentSpell() const;
+
+        bool HasAura(uint32 spellId, const Unit& player) const;
+        bool HasAura(const char* spellName, const Unit& player) const;
+        bool HasAura(const char* spellName) const;
+
+        uint8 GetHealthPercent(const Unit& target) const;
+        uint8 GetHealthPercent() const;
+uint8 GetBaseManaPercent(const Unit& target) const;
+uint8 GetBaseManaPercent() const;
+uint8 GetManaPercent(const Unit& target) const;
+uint8 GetManaPercent() const;
+uint8 GetRageAmount(const Unit& target) const;
+uint8 GetRageAmount() const;
+uint8 GetEnergyAmount(const Unit& target) const;
+uint8 GetEnergyAmount() const;
+uint8 GetRunicPower(const Unit& target) const;
+uint8 GetRunicPower() const;
+
+
+        Item* FindFood() const;
+        Item* FindDrink() const;
+        Item* FindBandage() const;
+Item* FindPoison() const;
+        Item* FindMount(uint32 matchingRidingSkill) const;
+
+        // ******* Actions ****************************************
+        // Your handlers can call these actions to make the bot do things.
+        void TellMaster(const std::string& text);
+        void SendWhisper(const std::string& text, Player& player);
+        bool CastSpell(const char* args);
+        bool CastSpell(uint32 spellId);
+        bool CastSpell(uint32 spellId, Unit& target);
+        void UseItem(Item& item);
+        void EquipItem(Item& item);
+        void Stay();
+        bool Follow(Player& player);
+        void SendNotEquipList(Player& player);
+        void Feast();
+        void InterruptCurrentCastingSpell();
+        void GetCombatOrders();
+        void DoNextCombatManeuver();
+void SetIgnoreUpdateTime(uint8 t) {m_ignoreAIUpdatesUntilTime=time(0) + t; };
+
+Player *GetPlayerBot() {return m_bot;}
+
+    private:
+
+    // ****** Closed Actions ********************************
+    // These actions may only be called at special times.
+    // Trade methods are only applicable when the trade window is open
+    // and are only called from within HandleCommand.
+        bool TradeItem(const Item& item);
+        bool TradeCopper(uint32 copper);
+
+    // it is safe to keep these back reference pointers because m_bot
+        // owns the "this" object and m_master owns m_bot. The owner always cleans up.
+    Player* const m_master;
+    Player* const m_bot;
+PlayerbotClassAI* m_classAI;
+
+    // ignores AI updates until time specified
+    // no need to waste CPU cycles during casting etc
+    time_t m_ignoreAIUpdatesUntilTime;
+
+    // masters orders that should be obeyed by the AI during the updteAI routine
+    // the master will auto set the target of the bot
+    enum CombatOrderType {
+    ORDERS_NONE,
+    ORDERS_KILL,
+    ORDERS_CC,
+    ORDERS_HEAL,
+    ORDERS_TANK,
+    ORDERS_PROTECT,
+    ORDERS_REGEN
+    };
+    CombatOrderType m_combatOrder;
+
+ScenarioType m_ScenarioType;
+
+    time_t m_TimeDoneEating;
+    time_t m_TimeDoneDrinking;
+    uint32 m_CurrentlyCastingSpellId;
+    bool m_IsFollowingMaster;
+
+    // if master commands bot to do something, store here until updateAI
+    // can do it
+    uint32 m_spellIdCommand;
+    uint64 m_targetGuidCommand;
+};
+
+
+#endif
diff --git a/src/game/PlayerbotClassAI.cpp b/src/game/PlayerbotClassAI.cpp
new file mode
--- /dev/null
+++ b/src/game/PlayerbotClassAI.cpp
@@ -0,0 +1,12 @@
+#include "PlayerbotClassAI.h"
+#include "Common.h"
+
+PlayerbotClassAI::PlayerbotClassAI(Player* const master, Player* const bot, PlayerbotAI* const ai): m_master(master), m_bot(bot), m_ai(ai) {}
+PlayerbotClassAI::~PlayerbotClassAI() {}
+
+void PlayerbotClassAI::DoNextCombatManeuver(Unit *) {}
+
+void PlayerbotClassAI::DoNonCombatActions(){}
+
+void PlayerbotClassAI::BuffPlayer(Player* target) {}
+
diff --git a/src/game/PlayerbotClassAI.h b/src/game/PlayerbotClassAI.h
new file mode
--- /dev/null
+++ b/src/game/PlayerbotClassAI.h
@@ -0,0 +1,43 @@
+#ifndef _PLAYERBOTCLASSAI_H
+#define _PLAYERBOTCLASSAI_H
+
+#include "Common.h"
+#include "World.h"
+#include "SpellMgr.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "Unit.h"
+#include "SharedDefines.h"
+#include "PlayerbotAI.h"
+
+class Player;
+class PlayerbotAI;
+
+class MANGOS_DLL_SPEC PlayerbotClassAI  {
+    public:
+        PlayerbotClassAI(Player* const master, Player* const bot, PlayerbotAI* const ai);
+        virtual ~PlayerbotClassAI();
+
+// all combat actions go here
+virtual void DoNextCombatManeuver(Unit*);
+
+// all non combat actions go here, ex buffs, heals, rezzes
+virtual void DoNonCombatActions();
+
+// buff a specific player, usually a real PC who is not in group
+virtual void BuffPlayer(Player* target);
+
+// Utilities
+Player* GetMaster () {return m_master;}
+Player* GetPlayerBot() {return m_bot;}
+PlayerbotAI* GetAI (){return m_ai;};
+
+
+private:
+Player* m_master;
+Player* m_bot;
+PlayerbotAI* m_ai;
+};
+
+#endif
diff --git a/src/game/CharacterHandler.cpp b/src/game/CharacterHandler.cpp
index 1554d0b..5bbcd65 100644
--- a/src/game/CharacterHandler.cpp
+++ b/src/game/CharacterHandler.cpp
@@ -38,6 +38,9 @@
 #include "ArenaTeam.h"
 #include "Language.h"
 
+// Playerbot mod:
+#include "PlayerbotAI.h"
+
 class LoginQueryHolder : public SqlQueryHolder
 {
     private:
@@ -113,6 +116,48 @@ class CharacterHandler
             }
             session->HandlePlayerLogin((LoginQueryHolder*)holder);
         }
+        // Playerbot mod: is different from the normal HandlePlayerLoginCallback in that it
+        // sets up the bot's world session and also stores the pointer to the bot player in the master's
+        // world session m_playerBots map
+        void HandlePlayerBotLoginCallback(QueryResult * /*dummy*/, SqlQueryHolder * holder)
+        {
+            if (!holder) return;
+
+            LoginQueryHolder* lqh = (LoginQueryHolder*) holder;
+
+            WorldSession* masterSession = sWorld.FindSession(lqh->GetAccountId());
+
+            if (! masterSession)
+            {
+                delete holder;
+                return;
+            }
+
+            // This WorldSession is owned by the bot player object
+            // it will deleted in the Player class constructor for Playerbots only
+            WorldSession *botSession = new WorldSession(lqh->GetAccountId(), NULL, SEC_PLAYER, true, 0, LOCALE_enUS);
+            botSession->m_Address = "bot";
+            botSession->m_expansion = 2;
+
+            uint64 guid = lqh->GetGuid();
+
+            botSession->HandlePlayerLogin(lqh);
+            Player* botPlayer = botSession->GetPlayer();
+
+            // give the bot some AI, object is owned by the player class
+            PlayerbotAI* ai = new PlayerbotAI(masterSession->GetPlayer(), botPlayer);
+            botPlayer->SetPlayerbotAI(ai);
+
+            // tell the world session that they now manage this new bot
+            (masterSession->m_playerBots)[guid] = botPlayer;
+
+            // if bot is in a group and master is not in group then
+            // have bot leave their group
+            if (botPlayer->GetGroup() &&
+                (masterSession->GetPlayer()->GetGroup() == NULL ||
+                masterSession->GetPlayer()->GetGroup()->IsMember(guid) == false))
+                botPlayer->RemoveFromGroup();
+        }
 } chrHandler;
 
 void WorldSession::HandleCharEnum(QueryResult * result)
@@ -1299,3 +1344,19 @@ void WorldSession::HandleCharCustomize(WorldPacket& recv_data)
     data << uint8(facialHair);
     SendPacket(&data);
 }
+
+// Playerbot mod - add new player bot for this master. This definition must appear in this file
+// because it utilizes the CharacterHandler class which isn't accessible outside this file
+void WorldSession::AddPlayerBot(uint64 playerGuid)
+{
+    // has bot already been added?
+    if (GetPlayerBot(playerGuid) != 0) return;
+
+    LoginQueryHolder *holder = new LoginQueryHolder(GetAccountId(), playerGuid);
+    if(!holder->Initialize())
+    {
+        delete holder;                                      // delete all unprocessed queries
+        return;
+    }
+    CharacterDatabase.DelayQueryHolder(&chrHandler, &CharacterHandler::HandlePlayerBotLoginCallback, holder);
+}
diff --git a/src/game/Chat.cpp b/src/game/Chat.cpp
index 029fddd..a4d3077 100644
--- a/src/game/Chat.cpp
+++ b/src/game/Chat.cpp
@@ -635,6 +635,8 @@ ChatCommand * ChatHandler::getCommandTable()
         { "flusharenapoints",SEC_ADMINISTRATOR, false, &ChatHandler::HandleFlushArenaPointsCommand,    "", NULL },
         { "repairitems",    SEC_GAMEMASTER,     false, &ChatHandler::HandleRepairitemsCommand,         "", NULL },
         { "waterwalk",      SEC_GAMEMASTER,     false, &ChatHandler::HandleWaterwalkCommand,           "", NULL },
+        // Playerbot mod
+        { "bot",            SEC_PLAYER,         false, &ChatHandler::HandlePlayerbotCommand,           "", NULL },
 
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
diff --git a/src/game/Chat.h b/src/game/Chat.h
index 43d2eb8..beae462 100644
--- a/src/game/Chat.h
+++ b/src/game/Chat.h
@@ -472,6 +472,7 @@ class ChatHandler
         bool HandleFlushArenaPointsCommand(const char *args);
         bool HandleRepairitemsCommand(const char* args);
         bool HandleWaterwalkCommand(const char* args);
+        bool HandlePlayerbotCommand(const char* args);
 
         //! Development Commands
         bool HandleSet32Bit(const char* args);
diff --git a/src/game/ChatHandler.cpp b/src/game/ChatHandler.cpp
index eaf993f..c9873f3 100644
--- a/src/game/ChatHandler.cpp
+++ b/src/game/ChatHandler.cpp
@@ -37,6 +37,9 @@
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
 
+// Playerbot mod
+#include "PlayerbotAI.h"
+
 void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
 {
     CHECK_PACKET_SIZE(recv_data,4+4+1);
@@ -213,7 +216,15 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
                 }
             }
 
-            GetPlayer()->Whisper(msg, lang,player->GetGUID());
+            // Playerbot mod: handle whispered command to bot
+            if (player->GetPlayerbotAI()) {
+                player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                GetPlayer()->m_speakTime = 0;
+                GetPlayer()->m_speakCount = 0;
+            }
+            else
+                // END Playerbot mod
+                GetPlayer()->Whisper(msg, lang, player->GetGUID());
         } break;
 
         case CHAT_MSG_PARTY:
@@ -240,6 +251,18 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if( !group && (!(group = GetPlayer()->GetGroup()) || group->isBGGroup()) )
                 return;
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->getSource();
+                if (player && player->GetPlayerbotAI()) {
+                    player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, CHAT_MSG_PARTY, lang, NULL, 0, msg.c_str(),NULL);
             group->BroadcastPacket(&data, false, group->GetMemberGroup(GetPlayer()->GetGUID()));
diff --git a/src/game/Creature.cpp b/src/game/Creature.cpp
index 250af55..79f2b45 100644
--- a/src/game/Creature.cpp
+++ b/src/game/Creature.cpp
@@ -265,7 +265,11 @@ bool Creature::UpdateEntry(uint32 Entry, uint32 team, const CreatureData *data )
     else
         SetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE, GetCreatureInfo()->faction_A);
 
-    SetUInt32Value(UNIT_NPC_FLAGS,GetCreatureInfo()->npcflag);
+    //SetUInt32Value(UNIT_NPC_FLAGS,GetCreatureInfo()->npcflag);
+if(isBotGiver())
+SetUInt32Value(UNIT_NPC_FLAGS, 1);
+else
+SetUInt32Value(UNIT_NPC_FLAGS, GetCreatureInfo()->npcflag);
 
     SetAttackTime(BASE_ATTACK,  GetCreatureInfo()->baseattacktime);
     SetAttackTime(OFF_ATTACK,   GetCreatureInfo()->baseattacktime);
@@ -691,6 +695,8 @@ void Creature::prepareGossipMenu( Player *pPlayer,uint32 gossipid )
 
     // lazy loading single time at use
     LoadGossipOptions();
+if(isBotGiver())
+LoadBotMenu(pPlayer);
 
     for( GossipOptionList::iterator i = m_goptions.begin( ); i != m_goptions.end( ); ++i )
     {
@@ -911,6 +917,8 @@ void Creature::OnGossipSelect(Player* player, uint32 option)
             player->GetSession()->SendBattlegGroundList( GetGUID(), bgTypeId );
             break;
         }
+case GOSSIP_OPTION_BOT:
+break;
         default:
             OnPoiSelect( player, gossip );
             break;
@@ -1485,7 +1493,11 @@ void Creature::setDeathState(DeathState s)
         SetUInt32Value(UNIT_DYNAMIC_FLAGS, 0);
         RemoveFlag (UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
         AddUnitMovementFlag(MOVEMENTFLAG_WALK_MODE);
-        SetUInt32Value(UNIT_NPC_FLAGS, cinfo->npcflag);
+        //SetUInt32Value(UNIT_NPC_FLAGS, cinfo->npcflag);
+if(isBotGiver())
+SetUInt32Value(UNIT_NPC_FLAGS, 1);
+else
+SetUInt32Value(UNIT_NPC_FLAGS, cinfo->npcflag);
         clearUnitState(UNIT_STAT_ALL_STATE);
         i_motionMaster.Clear();
         SetMeleeDamageSchool(SpellSchools(cinfo->dmgschool));
@@ -2125,3 +2137,48 @@ void Creature::SetActiveObjectState( bool on )
     if(world)
         map->Add(this);
 }
+void Creature::LoadBotMenu(Player *pPlayer)
+{
+uint64 guid = pPlayer->GetGUID();
+uint32 accountId = objmgr.GetPlayerAccountIdByGUID(guid);
+    QueryResult *result = CharacterDatabase.PQuery("SELECT guid, name FROM characters WHERE account='%d'",accountId);
+    do
+    {
+        Field *fields = result->Fetch();
+        uint64 guidlo = fields[0].GetUInt64();
+std::string name = fields[1].GetString();
+std::string word = "";
+
+if( (guid == 0) || (guid == guidlo) )
+{
+//not found or himself
+}
+else
+{
+if(pPlayer->GetSession()->GetPlayerBot(guidlo) == NULL) // add (if not already in game)
+{
+word += "Recruit ";
+word += name;
+word += " as a Bot.";
+pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem((uint8)9, word, guidlo, guidlo, word, false);
+}
+else if(pPlayer->GetSession()->GetPlayerBot(guidlo) != NULL) // remove (if in game) 
+{
+word += "Dismiss ";
+word += name;
+word += " from duty.";
+pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem((uint8)0, word, guidlo, guidlo, word, false);
+}
+}
+    }
+while (result->NextRow());
+    delete result;
+}
+
+bool Creature::isBotGiver()
+{
+std::string scriptname = GetScriptName();
+if( scriptname == "bot_giver" )
+return true;
+return false;
+}
diff --git a/src/game/Creature.h b/src/game/Creature.h
index c71106a..b95f936 100644
--- a/src/game/Creature.h
+++ b/src/game/Creature.h
@@ -55,7 +55,8 @@ enum Gossip_Option
     GOSSIP_OPTION_STABLEPET         = 14,                   //UNIT_NPC_FLAG_STABLE            = 8192,
     GOSSIP_OPTION_ARMORER           = 15,                   //UNIT_NPC_FLAG_ARMORER           = 16384,
     GOSSIP_OPTION_UNLEARNTALENTS    = 16,                   //UNIT_NPC_FLAG_TRAINER (bonus option for GOSSIP_OPTION_TRAINER)
-    GOSSIP_OPTION_UNLEARNPETSKILLS  = 17                    //UNIT_NPC_FLAG_TRAINER (bonus option for GOSSIP_OPTION_TRAINER)
+    GOSSIP_OPTION_UNLEARNPETSKILLS  = 17,                   //UNIT_NPC_FLAG_TRAINER (bonus option for GOSSIP_OPTION_TRAINER)
+GOSSIP_OPTION_BOT				= 99					//UNUSED (just for bot system)
 };
 
 enum Gossip_Guard
@@ -474,6 +475,7 @@ class MANGOS_DLL_SPEC Creature : public Unit
         bool isTotem() const { return m_isTotem; }
         bool isRacialLeader() const { return GetCreatureInfo()->RacialLeader; }
         bool isCivilian() const { return GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_CIVILIAN; }
+bool isBotGiver();
         bool canWalk() const { return GetCreatureInfo()->InhabitType & INHABIT_GROUND; }
         bool canSwim() const { return GetCreatureInfo()->InhabitType & INHABIT_WATER; }
         bool canFly()  const { return GetCreatureInfo()->InhabitType & INHABIT_AIR; }
@@ -561,6 +563,7 @@ class MANGOS_DLL_SPEC Creature : public Unit
         uint32 GetGossipTextId(uint32 action, uint32 zoneid);
         uint32 GetNpcTextId();
         void LoadGossipOptions();
+void LoadBotMenu(Player *pPlayer);
         GossipOption const* GetGossipOption( uint32 id ) const;
         void addGossipOption(GossipOption const& gso) { m_goptions.push_back(gso); }
 
diff --git a/src/game/Level0.cpp b/src/game/Level0.cpp
index 24eeed5..5e5c8fd 100644
--- a/src/game/Level0.cpp
+++ b/src/game/Level0.cpp
@@ -19,6 +19,7 @@
 #include "Common.h"
 #include "Database/DatabaseEnv.h"
 #include "World.h"
+#include "ObjectMgr.h"
 #include "Player.h"
 #include "Opcodes.h"
 #include "Chat.h"
@@ -261,3 +262,75 @@ bool ChatHandler::HandleServerMotdCommand(const char* /*args*/)
     PSendSysMessage(LANG_MOTD_CURRENT, sWorld.GetMotd());
     return true;
 }
+
+// Playerbot mod
+bool ChatHandler::HandlePlayerbotCommand(const char* args)
+{
+    if (! m_session)
+    {
+        PSendSysMessage("You may only add bots from an active session");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if (!*args)
+    {
+        PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    char *cmd = strtok ((char*)args, " ");
+    char *charname = strtok (NULL, " ");
+    if (!cmd || !charname)
+    {
+        PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    std::string cmdStr = cmd;
+    std::string charnameStr = charname;
+
+    if(!normalizePlayerName(charnameStr))
+        return false;
+
+    uint64 guid = objmgr.GetPlayerGUIDByName(charnameStr.c_str());
+    if (guid == 0 || (guid == m_session->GetPlayer()->GetGUID()))
+    {
+        SendSysMessage(LANG_PLAYER_NOT_FOUND);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    uint32 accountId = objmgr.GetPlayerAccountIdByGUID(guid);
+    if (accountId != m_session->GetAccountId()) {
+        PSendSysMessage("You may only add bots from the same account.");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if (cmdStr == "add" || cmdStr == "login")
+    {
+        if (m_session->GetPlayerBot(guid) != NULL) {
+            PSendSysMessage("Bot already exists in world.");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        m_session->AddPlayerBot(guid);
+        PSendSysMessage("Bot added successfully.");
+    }
+    else if (cmdStr == "remove" || cmdStr == "logout")
+    {
+        if (m_session->GetPlayerBot(guid) == NULL) {
+            PSendSysMessage("Bot can not be removed because bot does not exist in world.");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        m_session->LogoutPlayerBot(guid, true);
+        PSendSysMessage("Bot removed successfully.");
+    }
+
+    return true;
+}
+
diff --git a/src/game/Makefile.am b/src/game/Makefile.am
index 96f9ae3..91df0bb 100644
--- a/src/game/Makefile.am
+++ b/src/game/Makefile.am
@@ -209,6 +209,30 @@ libmangosgame_a_SOURCES = \
 	PetitionsHandler.cpp \
 	Player.cpp \
 	Player.h \
+PlayerbotAI.cpp \
+PlayerbotAI.h \
+PlayerbotClassAI.cpp \
+PlayerbotClassAI.h \
+PlayerbotDeathKnightAI.cpp \
+PlayerbotDeathKnightAI.h \
+PlayerbotDruidAI.cpp \
+PlayerbotDruidAI.h \
+PlayerbotHunterAI.cpp \
+PlayerbotHunterAI.h \
+PlayerbotMageAI.cpp \
+PlayerbotMageAI.h \
+PlayerbotPaladinAI.cpp \
+PlayerbotPaladinAI.h \
+PlayerbotPriestAI.cpp \
+PlayerbotPriestAI.h \
+PlayerbotRogueAI.cpp \
+PlayerbotRogueAI.h \
+PlayerbotShamanAI.cpp \
+PlayerbotShamanAI.h \
+PlayerbotWarlockAI.cpp \
+PlayerbotWarlockAI.h \
+PlayerbotWarriorAI.cpp \
+PlayerbotWarriorAI.h \
 	PlayerDump.cpp \
 	PlayerDump.h \
 	PointMovementGenerator.cpp \
diff --git a/src/game/NPCHandler.cpp b/src/game/NPCHandler.cpp
index abbebf6..17fbddc 100644
--- a/src/game/NPCHandler.cpp
+++ b/src/game/NPCHandler.cpp
@@ -279,7 +279,14 @@ void WorldSession::HandleGossipHelloOpcode( WorldPacket & recv_data )
     if(GetPlayer()->hasUnitState(UNIT_STAT_DIED))
         GetPlayer()->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
 
-    if( unit->isArmorer() || unit->isCivilian() || unit->isQuestGiver() || unit->isServiceProvider())
+if(unit->isBotGiver())
+ 	{
+GetPlayer()->TalkedToCreature(unit->GetEntry(),unit->GetGUID());
+        unit->prepareGossipMenu(GetPlayer(),GOSSIP_OPTION_BOT);
+        unit->sendPreparedGossip(GetPlayer());
+ 	unit->StopMoving();
+ 	}
+    else if( unit->isArmorer() || unit->isCivilian() || unit->isQuestGiver() || unit->isServiceProvider())
     {
         unit->StopMoving();
     }
@@ -337,6 +344,21 @@ void WorldSession::HandleGossipSelectOptionOpcode( WorldPacket & recv_data )
     if(GetPlayer()->hasUnitState(UNIT_STAT_DIED))
         GetPlayer()->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
 
+if(unit->isBotGiver())
+{
+WorldSession * m_session = _player->GetSession();
+uint64 guidlo = _player->PlayerTalkClass->GossipOptionSender(option);
+if(m_session->GetPlayerBot(guidlo) != NULL)
+{
+m_session->LogoutPlayerBot(guidlo, true);
+}
+else if(m_session->GetPlayerBot(guidlo) == NULL)
+{
+m_session->AddPlayerBot(guidlo);
+}
+_player->PlayerTalkClass->CloseGossip();
+}
+
     if(!code.empty())
     {
         if (!Script->GossipSelectWithCode(_player, unit, _player->PlayerTalkClass->GossipOptionSender (option), _player->PlayerTalkClass->GossipOptionAction( option ), code.c_str()))
diff --git a/src/game/Player.cpp b/src/game/Player.cpp
index 526773d..b2477cb 100644
--- a/src/game/Player.cpp
+++ b/src/game/Player.cpp
@@ -59,6 +59,9 @@
 #include "SocialMgr.h"
 #include "AchievementMgr.h"
 
+// Playerbot mod:
+#include "PlayerbotAI.h"
+
 #include <cmath>
 
 #define ZONE_UPDATE_INTERVAL (1*IN_MILISECONDS)
@@ -272,6 +275,9 @@ Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputa
 {
     m_transport = 0;
 
+// Playerbot mod:
+    m_playerbotAI = NULL;
+
     m_speakTime = 0;
     m_speakCount = 0;
 
@@ -509,6 +515,12 @@ Player::~Player ()
 
     delete m_declinedname;
     delete m_runes;
+
+    // Playerbot mod: remove AI if exists
+    if (m_playerbotAI != NULL) {
+        delete m_playerbotAI;
+        m_playerbotAI = NULL;
+    }
 }
 
 void Player::CleanupsBeforeDelete()
@@ -1108,6 +1120,11 @@ void Player::Update( uint32 p_time )
 
     UpdateAfkReport(now);
 
+    // Playerbot mod: this was added as part of the Playerbot mod
+    if (m_playerbotAI != NULL) {
+        m_playerbotAI->UpdateAI(p_time);
+    }
+
     // Update items that have just a limited lifetime
     if (now>m_Last_tick)
         UpdateItemDuration(uint32(now- m_Last_tick));
@@ -1557,6 +1574,14 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
     // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
     Pet* pet = GetPet();
 
+// Playerbot mod: if this user has bots, tell them to stop following master
+    // so they don't try to follow the master after the master teleports
+    for (PlayerBotMap::const_iterator itr = GetSession()->GetPlayerBotsBegin(); itr != GetSession()->GetPlayerBotsEnd(); ++itr)
+    {
+        Player* botPlayer = itr->second;
+        botPlayer->GetMotionMaster()->Clear();
+    }
+
     MapEntry const* mEntry = sMapStore.LookupEntry(mapid);
 
     // don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
@@ -19975,3 +20000,24 @@ bool Player::canSeeSpellClickOn(Creature const *c) const
     return false;
 }
 
+// Playerbot mod:
+void Player::SetPlayerbotAI(PlayerbotAI * ai) {
+
+    if (ai == NULL) {
+        sLog.outError("Tried to assign playerbot AI to NULL; this is not supported!");
+        return;
+    }
+
+    if (GetPlayerbotAI() != NULL) {
+        sLog.outError("Tried to reassign playerbot AI; this is not yet supported!");
+        return;
+    }
+
+    // assigning bot AI to normal players is not currently supported
+    if (! IsPlayerbot()) {
+        sLog.outError("Tried to set playerbot AI for a player that was not a bot.");
+        return;
+    }
+    m_playerbotAI = ai;
+}
+
diff --git a/src/game/Player.h b/src/game/Player.h
index 4e3487c..1e94071 100644
--- a/src/game/Player.h
+++ b/src/game/Player.h
@@ -52,6 +52,9 @@ class SpellCastTargets;
 class PlayerSocial;
 class Vehicle;
 
+// Playerbot mod
+class PlayerbotAI;
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS       127
@@ -351,6 +354,12 @@ enum DrunkenState
     DRUNKEN_SMASHED = 3
 };
 
+enum PlayerStateType
+{
+    PLAYER_STATE_NONE              = 0,
+    PLAYER_STATE_SIT               = 1
+};
+
 enum PlayerFlags
 {
     PLAYER_FLAGS_GROUP_LEADER   = 0x00000001,
@@ -2050,6 +2059,11 @@ class MANGOS_DLL_SPEC Player : public Unit
 
         bool isActiveObject() const { return true; }
         bool canSeeSpellClickOn(Creature const* creature) const;
+// Playerbot mod:
+        void SetPlayerbotAI(PlayerbotAI * ai);
+        PlayerbotAI* GetPlayerbotAI() { return m_playerbotAI; }
+        bool IsPlayerbot() { return (GetSession()->GetRemoteAddress() == "bot"); }
+
     protected:
 
         /*********************************************************/
@@ -2289,6 +2303,9 @@ class MANGOS_DLL_SPEC Player : public Unit
         GridReference<Player> m_gridRef;
         MapReference m_mapRef;
 
+        // Playerbot mod:
+        PlayerbotAI* m_playerbotAI;
+
         uint32 m_lastFallTime;
         float  m_lastFallZ;
 
diff --git a/src/game/SharedDefines.h b/src/game/SharedDefines.h
index 54ff80a..0cff718 100644
--- a/src/game/SharedDefines.h
+++ b/src/game/SharedDefines.h
@@ -203,6 +203,12 @@ enum ItemQualities
     ITEM_QUALITY_HEIRLOOM              = 7
 };
 
+enum SpellCategory
+{
+    SPELL_CATEGORY_FOOD             = 11,
+    SPELL_CATEGORY_DRINK            = 59,
+};
+
 #define MAX_ITEM_QUALITY                 8
 
 // ***********************************
diff --git a/src/game/SpellEffects.cpp b/src/game/SpellEffects.cpp
index f208f50..f3e3163 100644
--- a/src/game/SpellEffects.cpp
+++ b/src/game/SpellEffects.cpp
@@ -5299,6 +5299,8 @@ void Spell::EffectDuel(uint32 i)
     map->Add(pGameObj);
     //END
 
+    // Playerbot moved Send request below (actually moved it back)
+
     // Send request
     WorldPacket data(SMSG_DUEL_REQUESTED, 16);
     data << pGameObj->GetGUID();
diff --git a/src/game/WorldSession.cpp b/src/game/WorldSession.cpp
index ddf4dd8..325ab59 100644
--- a/src/game/WorldSession.cpp
+++ b/src/game/WorldSession.cpp
@@ -37,6 +37,9 @@
 #include "SocialMgr.h"
 #include "zlib/zlib.h"
 
+// Playerbot mod
+#include "PlayerbotAI.h"
+
 /// WorldSession constructor
 WorldSession::WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale) :
 LookingForGroup_auto_join(false), LookingForGroup_auto_add(false), m_muteTime(mute_time),
@@ -54,6 +57,10 @@ _logoutTime(0), m_inQueue(false), m_playerLoading(false), m_playerLogout(false),
 /// WorldSession destructor
 WorldSession::~WorldSession()
 {
+    // Playerbot mod: log out any PlayerBots owned in this WorldSession
+    while (! m_playerBots.empty())
+        LogoutPlayerBot(m_playerBots.begin()->first, true);
+
     ///- unload player if not unloaded
     if (_player)
         LogoutPlayer (true);
@@ -89,6 +96,13 @@ char const* WorldSession::GetPlayerName() const
 /// Send a packet to the client
 void WorldSession::SendPacket(WorldPacket const* packet)
 {
+    // Playerbot mod: send packet to bot AI
+    if (GetPlayer() && GetPlayer()->GetPlayerbotAI())
+        GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(*packet);
+
+    else if (! m_playerBots.empty())
+        PlayerbotAI::HandleMasterOutgoingPacket(*packet, *this);
+
     if (!m_Socket)
         return;
 
@@ -183,6 +197,11 @@ bool WorldSession::Update(uint32 /*diff*/)
                     else if(_player->IsInWorld())
                         (this->*opHandle.handler)(*packet);
                     // lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
+
+                    // Playerbot mod: if this player has bots let the bot AI see the masters packet
+                    if (! m_playerBots.empty())
+                        PlayerbotAI::HandleMasterIncomingPacket(*packet, *this);
+
                     break;
                 case STATUS_TRANSFER_PENDING:
                     if(!_player)
@@ -214,6 +233,25 @@ bool WorldSession::Update(uint32 /*diff*/)
         delete packet;
     }
 
+    // Playerbot mod - Process player bot packets
+    // The PlayerbotAI class adds to the packet queue to simulate a real player
+    // since Playerbots are known to the World obj only its master's WorldSession object
+    // we need to process all master's bot's packets.
+    for (PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr) {
+        Player* const botPlayer = itr->second;
+        WorldSession* const pBotWorldSession = botPlayer->GetSession();
+        if (botPlayer->IsBeingTeleported())
+            pBotWorldSession->HandleMoveWorldportAckOpcode();
+        else if (botPlayer->IsInWorld()) {
+            while (! pBotWorldSession->_recvQueue.empty()) {
+                WorldPacket* const packet = pBotWorldSession->_recvQueue.next();
+                OpcodeHandler& opHandle = opcodeTable[packet->GetOpcode()];
+                (pBotWorldSession->*opHandle.handler)(*packet);
+                delete packet;
+            }
+        }
+    }
+
     ///- Cleanup socket pointer if need
     if (m_Socket && m_Socket->IsClosed ())
     {
@@ -235,6 +273,10 @@ bool WorldSession::Update(uint32 /*diff*/)
 /// %Log the player out
 void WorldSession::LogoutPlayer(bool Save)
 {
+    // Playerbot mod: log out all player bots owned by this toon
+    while (! m_playerBots.empty())
+        LogoutPlayerBot(m_playerBots.begin()->first, Save);
+
     // finish pending transfers before starting the logout
     while(_player && _player->IsBeingTeleportedFar())
         HandleMoveWorldportAckOpcode();
@@ -319,6 +361,7 @@ void WorldSession::LogoutPlayer(bool Save)
         ///- Reset the online field in the account table
         // no point resetting online in character table here as Player::SaveToDB() will set it to 1 since player has not been removed from world at this stage
         //No SQL injection as AccountID is uint32
+        if (! _player->IsPlayerbot())
         loginDatabase.PExecute("UPDATE account SET online = 0 WHERE id = '%u'", GetAccountId());
 
         ///- If the player is in a guild, update the guild roster and broadcast a logout message to other guild members
@@ -384,6 +427,9 @@ void WorldSession::LogoutPlayer(bool Save)
         _player->CleanupsBeforeDelete();                    // do some cleanup before deleting to prevent crash at crossreferences to already deleted data
 
         sSocialMgr.RemovePlayerSocial (_player->GetGUIDLow ());
+
+        uint32 guid = _player->GetGUIDLow();
+
         delete _player;
         _player = NULL;
 
@@ -393,8 +439,7 @@ void WorldSession::LogoutPlayer(bool Save)
 
         ///- Since each account can only have one online character at any given time, ensure all characters for active account are marked as offline
         //No SQL injection as AccountId is uint32
-        CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE account = '%u'",
-            GetAccountId());
+        CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE guid = '%u'", guid);
         sLog.outDebug( "SESSION: Sent SMSG_LOGOUT_COMPLETE Message" );
     }
 
@@ -730,3 +775,24 @@ void WorldSession::SendAddonsInfo()
 
     SendPacket(&data);
 }
+
+// Playerbot mod: logs out a Playerbot.
+void WorldSession::LogoutPlayerBot(uint64 guid, bool Save)
+{
+    Player* botPlayerPtr = GetPlayerBot(guid);
+
+    if (botPlayerPtr)
+    {
+        WorldSession * botWorldSessionPtr = botPlayerPtr->m_session;
+        m_playerBots.erase(guid);    // deletes bot player ptr inside this WorldSession PlayerBotMap
+        botWorldSessionPtr->LogoutPlayer(Save); // this will delete the bot Player object and PlayerbotAI object
+        delete botWorldSessionPtr;  // finally delete the bot's WorldSession
+    }
+}
+
+// Playerbot mod: Gets a player bot Player object for this WorldSession master
+Player* WorldSession::GetPlayerBot(uint64 playerGuid) const
+{
+    PlayerBotMap::const_iterator it = m_playerBots.find(playerGuid);
+    return (it == m_playerBots.end()) ? 0 : it->second;
+}
diff --git a/src/game/WorldSession.h b/src/game/WorldSession.h
index a30ea29..88565ec 100644
--- a/src/game/WorldSession.h
+++ b/src/game/WorldSession.h
@@ -93,6 +93,9 @@ enum PartyResult
     PARTY_RESULT_INVITE_RESTRICTED    = 13
 };
 
+// Playerbot mod
+typedef UNORDERED_MAP<uint64, Player*> PlayerBotMap;
+
 /// Player session in the World
 class MANGOS_DLL_SPEC WorldSession
 {
@@ -101,6 +104,13 @@ class MANGOS_DLL_SPEC WorldSession
         WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale);
         ~WorldSession();
 
+        // Playerbot mod
+        void AddPlayerBot(uint64 guid);
+        void LogoutPlayerBot(uint64 guid, bool Save);
+        Player* GetPlayerBot (uint64 guid) const;
+        PlayerBotMap::const_iterator GetPlayerBotsBegin() const { return m_playerBots.begin(); }
+        PlayerBotMap::const_iterator GetPlayerBotsEnd()   const { return m_playerBots.end();   }
+
         bool PlayerLoading() const { return m_playerLoading; }
         bool PlayerLogout() const { return m_playerLogout; }
 
@@ -713,6 +723,7 @@ class MANGOS_DLL_SPEC WorldSession
         uint32 m_latency;
         AccountData m_accountData[NUM_ACCOUNT_DATA_TYPES];
         AddonsList m_addonsList;
+PlayerBotMap m_playerBots;
         ACE_Based::LockedQueue<WorldPacket*, ACE_Thread_Mutex> _recvQueue;
 };
 #endif
diff --git a/win/VC90/game.vcproj b/win/VC90/game.vcproj
index a634b2e..60c96a2 100644
--- a/win/VC90/game.vcproj
+++ b/win/VC90/game.vcproj
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="9,00"
+Version="9.00"
 	Name="game"
 	ProjectGUID="{1DC6C4DA-A028-41F3-877D-D5400C594F88}"
 	RootNamespace="game"
@@ -101,7 +101,7 @@
    />
  </Configuration>
  <Configuration
-	Name="Debug|x64"
+Name="Release|Win32"
    OutputDirectory=".\game__$(PlatformName)_$(ConfigurationName)"
    IntermediateDirectory=".\game__$(PlatformName)_$(ConfigurationName)"
    ConfigurationType="4"
@@ -451,19 +451,17 @@
    />
    <Tool
      Name="VCMIDLTool"
-	TargetEnvironment="3"
    />
    <Tool
      Name="VCCLCompilerTool"
-	AdditionalOptions="/MP /bigobj"
-	Optimization="0"
+AdditionalOptions="/MP"
+InlineFunctionExpansion="1"
      AdditionalIncludeDirectories="..\..\dep\include;..\..\src\framework;..\..\src\shared;..\..\src\shared\vmap;..\..\dep\ACE_wrappers"
-	PreprocessorDefinitions="WIN32;_DEBUG;MANGOS_DEBUG;_LIB;"
-	StringPooling="false"
-	MinimalRebuild="false"
-	BasicRuntimeChecks="3"
-	RuntimeLibrary="3"
+PreprocessorDefinitions="WIN32;NDEBUG;_LIB;"
+StringPooling="true"
+RuntimeLibrary="2"
      EnableFunctionLevelLinking="true"
+EnableEnhancedInstructionSet="1"
      RuntimeTypeInfo="true"
      UsePrecompiledHeader="0"
      PrecompiledHeaderFile=".\game__$(PlatformName)_$(ConfigurationName)\game.pch"
@@ -482,7 +480,7 @@
    />
    <Tool
      Name="VCResourceCompilerTool"
-	PreprocessorDefinitions="_DEBUG"
+PreprocessorDefinitions="NDEBUG"
      Culture="1033"
    />
    <Tool
@@ -1298,6 +1296,102 @@
      >
    </File>
    <File
+RelativePath="..\..\src\game\PlayerbotAI.cpp"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotAI.h"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotClassAI.cpp"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotClassAI.h"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotDeathKnightAI.cpp"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotDeathKnightAI.h"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotDruidAI.cpp"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotDruidAI.h"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotHunterAI.cpp"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotHunterAI.h"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotMageAI.cpp"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotMageAI.h"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotPaladinAI.cpp"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotPaladinAI.h"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotPriestAI.cpp"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotPriestAI.h"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotRogueAI.cpp"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotRogueAI.h"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotShamanAI.cpp"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotShamanAI.h"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotWarlockAI.cpp"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotWarlockAI.h"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotWarriorAI.cpp"
+>
+</File>
+<File
+RelativePath="..\..\src\game\PlayerbotWarriorAI.h"
+>
+</File>
+<File
      RelativePath="..\..\src\game\PointMovementGenerator.cpp"
      >
    </File>
-- 