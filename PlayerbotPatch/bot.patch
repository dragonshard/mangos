diff --git a/src/game/CharacterHandler.cpp b/src/game/CharacterHandler.cpp
index 1554d0b..5bbcd65 100644
--- a/src/game/CharacterHandler.cpp
+++ b/src/game/CharacterHandler.cpp
@@ -38,6 +38,9 @@
 #include "ArenaTeam.h"
 #include "Language.h"
 
+// Playerbot mod:
+#include "PlayerbotAI.h"
+
 class LoginQueryHolder : public SqlQueryHolder
 {
     private:
@@ -113,6 +116,48 @@ class CharacterHandler
             }
             session->HandlePlayerLogin((LoginQueryHolder*)holder);
         }
+        // Playerbot mod: is different from the normal HandlePlayerLoginCallback in that it
+        // sets up the bot's world session and also stores the pointer to the bot player in the master's
+        // world session m_playerBots map
+        void HandlePlayerBotLoginCallback(QueryResult * /*dummy*/, SqlQueryHolder * holder)
+        {
+            if (!holder) return;
+
+            LoginQueryHolder* lqh = (LoginQueryHolder*) holder;
+
+            WorldSession* masterSession = sWorld.FindSession(lqh->GetAccountId());
+
+            if (! masterSession)
+            {
+                delete holder;
+                return;
+            }
+
+            // This WorldSession is owned by the bot player object
+            // it will deleted in the Player class constructor for Playerbots only
+            WorldSession *botSession = new WorldSession(lqh->GetAccountId(), NULL, SEC_PLAYER, true, 0, LOCALE_enUS);
+            botSession->m_Address = "bot";
+            botSession->m_expansion = 2;
+
+            uint64 guid = lqh->GetGuid();
+
+            botSession->HandlePlayerLogin(lqh);
+            Player* botPlayer = botSession->GetPlayer();
+
+            // give the bot some AI, object is owned by the player class
+            PlayerbotAI* ai = new PlayerbotAI(masterSession->GetPlayer(), botPlayer);
+            botPlayer->SetPlayerbotAI(ai);
+
+            // tell the world session that they now manage this new bot
+            (masterSession->m_playerBots)[guid] = botPlayer;
+
+            // if bot is in a group and master is not in group then
+            // have bot leave their group
+            if (botPlayer->GetGroup() &&
+                (masterSession->GetPlayer()->GetGroup() == NULL ||
+                masterSession->GetPlayer()->GetGroup()->IsMember(guid) == false))
+                botPlayer->RemoveFromGroup();
+        }
 } chrHandler;
 
 void WorldSession::HandleCharEnum(QueryResult * result)
@@ -1299,3 +1344,19 @@ void WorldSession::HandleCharCustomize(WorldPacket& recv_data)
     data << uint8(facialHair);
     SendPacket(&data);
 }
+
+// Playerbot mod - add new player bot for this master. This definition must appear in this file
+// because it utilizes the CharacterHandler class which isn't accessible outside this file
+void WorldSession::AddPlayerBot(uint64 playerGuid)
+{
+    // has bot already been added?
+    if (GetPlayerBot(playerGuid) != 0) return;
+
+    LoginQueryHolder *holder = new LoginQueryHolder(GetAccountId(), playerGuid);
+    if(!holder->Initialize())
+    {
+        delete holder;                                      // delete all unprocessed queries
+        return;
+    }
+    CharacterDatabase.DelayQueryHolder(&chrHandler, &CharacterHandler::HandlePlayerBotLoginCallback, holder);
+}
diff --git a/src/game/Chat.cpp b/src/game/Chat.cpp
index 029fddd..a4d3077 100644
--- a/src/game/Chat.cpp
+++ b/src/game/Chat.cpp
@@ -635,6 +635,8 @@ ChatCommand * ChatHandler::getCommandTable()
         { "flusharenapoints",SEC_ADMINISTRATOR, false, &ChatHandler::HandleFlushArenaPointsCommand,    "", NULL },
         { "repairitems",    SEC_GAMEMASTER,     false, &ChatHandler::HandleRepairitemsCommand,         "", NULL },
         { "waterwalk",      SEC_GAMEMASTER,     false, &ChatHandler::HandleWaterwalkCommand,           "", NULL },
+        // Playerbot mod
+        { "bot",            SEC_PLAYER,         false, &ChatHandler::HandlePlayerbotCommand,           "", NULL },
 
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
diff --git a/src/game/Chat.h b/src/game/Chat.h
index 43d2eb8..beae462 100644
--- a/src/game/Chat.h
+++ b/src/game/Chat.h
@@ -472,6 +472,7 @@ class ChatHandler
         bool HandleFlushArenaPointsCommand(const char *args);
         bool HandleRepairitemsCommand(const char* args);
         bool HandleWaterwalkCommand(const char* args);
+        bool HandlePlayerbotCommand(const char* args);
 
         //! Development Commands
         bool HandleSet32Bit(const char* args);
diff --git a/src/game/ChatHandler.cpp b/src/game/ChatHandler.cpp
index eaf993f..c9873f3 100644
--- a/src/game/ChatHandler.cpp
+++ b/src/game/ChatHandler.cpp
@@ -37,6 +37,9 @@
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
 
+// Playerbot mod
+#include "PlayerbotAI.h"
+
 void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
 {
     CHECK_PACKET_SIZE(recv_data,4+4+1);
@@ -213,7 +216,15 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
                 }
             }
 
-            GetPlayer()->Whisper(msg, lang,player->GetGUID());
+            // Playerbot mod: handle whispered command to bot
+            if (player->GetPlayerbotAI()) {
+                player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                GetPlayer()->m_speakTime = 0;
+                GetPlayer()->m_speakCount = 0;
+            }
+            else
+                // END Playerbot mod
+                GetPlayer()->Whisper(msg, lang, player->GetGUID());
         } break;
 
         case CHAT_MSG_PARTY:
@@ -240,6 +251,18 @@ void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
             if( !group && (!(group = GetPlayer()->GetGroup()) || group->isBGGroup()) )
                 return;
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->getSource();
+                if (player && player->GetPlayerbotAI()) {
+                    player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, CHAT_MSG_PARTY, lang, NULL, 0, msg.c_str(),NULL);
             group->BroadcastPacket(&data, false, group->GetMemberGroup(GetPlayer()->GetGUID()));
diff --git a/src/game/Creature.cpp b/src/game/Creature.cpp
index 250af55..79f2b45 100644
--- a/src/game/Creature.cpp
+++ b/src/game/Creature.cpp
@@ -265,7 +265,11 @@ bool Creature::UpdateEntry(uint32 Entry, uint32 team, const CreatureData *data )
     else
         SetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE, GetCreatureInfo()->faction_A);
 
-    SetUInt32Value(UNIT_NPC_FLAGS,GetCreatureInfo()->npcflag);
+    //SetUInt32Value(UNIT_NPC_FLAGS,GetCreatureInfo()->npcflag);
+	if(isBotGiver())
+		SetUInt32Value(UNIT_NPC_FLAGS, 1);
+	else
+		SetUInt32Value(UNIT_NPC_FLAGS, GetCreatureInfo()->npcflag);
 
     SetAttackTime(BASE_ATTACK,  GetCreatureInfo()->baseattacktime);
     SetAttackTime(OFF_ATTACK,   GetCreatureInfo()->baseattacktime);
@@ -691,6 +695,8 @@ void Creature::prepareGossipMenu( Player *pPlayer,uint32 gossipid )
 
     // lazy loading single time at use
     LoadGossipOptions();
+	if(isBotGiver())
+		LoadBotMenu(pPlayer);
 
     for( GossipOptionList::iterator i = m_goptions.begin( ); i != m_goptions.end( ); ++i )
     {
@@ -911,6 +917,8 @@ void Creature::OnGossipSelect(Player* player, uint32 option)
             player->GetSession()->SendBattlegGroundList( GetGUID(), bgTypeId );
             break;
         }
+		case GOSSIP_OPTION_BOT:
+			break;
         default:
             OnPoiSelect( player, gossip );
             break;
@@ -1485,7 +1493,11 @@ void Creature::setDeathState(DeathState s)
         SetUInt32Value(UNIT_DYNAMIC_FLAGS, 0);
         RemoveFlag (UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
         AddUnitMovementFlag(MOVEMENTFLAG_WALK_MODE);
-        SetUInt32Value(UNIT_NPC_FLAGS, cinfo->npcflag);
+        //SetUInt32Value(UNIT_NPC_FLAGS, cinfo->npcflag);
+		if(isBotGiver())
+			SetUInt32Value(UNIT_NPC_FLAGS, 1);
+		else
+			SetUInt32Value(UNIT_NPC_FLAGS, cinfo->npcflag);
         clearUnitState(UNIT_STAT_ALL_STATE);
         i_motionMaster.Clear();
         SetMeleeDamageSchool(SpellSchools(cinfo->dmgschool));
@@ -2125,3 +2137,48 @@ void Creature::SetActiveObjectState( bool on )
     if(world)
         map->Add(this);
 }
+void Creature::LoadBotMenu(Player *pPlayer)
+{
+	uint64 guid = pPlayer->GetGUID();
+	uint32 accountId = objmgr.GetPlayerAccountIdByGUID(guid);
+    QueryResult *result = CharacterDatabase.PQuery("SELECT guid, name FROM characters WHERE account='%d'",accountId);
+    do
+    {
+        Field *fields = result->Fetch();
+        uint64 guidlo = fields[0].GetUInt64();
+		std::string name = fields[1].GetString();
+		std::string word = "";
+
+		if( (guid == 0) || (guid == guidlo) )
+		{
+			//not found or himself
+		}
+		else
+		{
+			if(pPlayer->GetSession()->GetPlayerBot(guidlo) == NULL) // add (if not already in game)
+			{
+				word += "Recruit ";
+				word += name;
+				word += " as a Bot.";
+				pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem((uint8)9, word, guidlo, guidlo, word, false);
+			}
+			else if(pPlayer->GetSession()->GetPlayerBot(guidlo) != NULL) // remove (if in game) 
+			{
+				word += "Dismiss ";
+				word += name;
+				word += " from duty.";
+				pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem((uint8)0, word, guidlo, guidlo, word, false);
+			}
+		}
+    }
+	while (result->NextRow());
+    delete result;
+}
+
+bool Creature::isBotGiver()
+{
+	std::string scriptname = GetScriptName();
+	if( scriptname == "bot_giver" )
+		return true;
+	return false;
+}
diff --git a/src/game/Creature.h b/src/game/Creature.h
index 9953a31..894b362 100644
--- a/src/game/Creature.h
+++ b/src/game/Creature.h
@@ -55,7 +55,8 @@ enum Gossip_Option
     GOSSIP_OPTION_STABLEPET         = 14,                   //UNIT_NPC_FLAG_STABLE            = 8192,
     GOSSIP_OPTION_ARMORER           = 15,                   //UNIT_NPC_FLAG_ARMORER           = 16384,
     GOSSIP_OPTION_UNLEARNTALENTS    = 16,                   //UNIT_NPC_FLAG_TRAINER (bonus option for GOSSIP_OPTION_TRAINER)
-    GOSSIP_OPTION_UNLEARNPETSKILLS  = 17                    //UNIT_NPC_FLAG_TRAINER (bonus option for GOSSIP_OPTION_TRAINER)
+    GOSSIP_OPTION_UNLEARNPETSKILLS  = 17,                   //UNIT_NPC_FLAG_TRAINER (bonus option for GOSSIP_OPTION_TRAINER)
+	GOSSIP_OPTION_BOT				= 99					//UNUSED (just for bot system)
 };
 
 enum Gossip_Guard
@@ -459,6 +460,7 @@ class MANGOS_DLL_SPEC Creature : public Unit
         bool isTotem() const { return m_isTotem; }
         bool isRacialLeader() const { return GetCreatureInfo()->RacialLeader; }
         bool isCivilian() const { return GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_CIVILIAN; }
+		bool isBotGiver();
         bool canWalk() const { return GetCreatureInfo()->InhabitType & INHABIT_GROUND; }
         bool canSwim() const { return GetCreatureInfo()->InhabitType & INHABIT_WATER; }
         bool canFly()  const { return GetCreatureInfo()->InhabitType & INHABIT_AIR; }
@@ -546,6 +548,7 @@ class MANGOS_DLL_SPEC Creature : public Unit
         uint32 GetGossipTextId(uint32 action, uint32 zoneid);
         uint32 GetNpcTextId();
         void LoadGossipOptions();
+		void LoadBotMenu(Player *pPlayer);
         GossipOption const* GetGossipOption( uint32 id ) const;
         void addGossipOption(GossipOption const& gso) { m_goptions.push_back(gso); }
 
diff --git a/src/game/Level0.cpp b/src/game/Level0.cpp
index 24eeed5..5e5c8fd 100644
--- a/src/game/Level0.cpp
+++ b/src/game/Level0.cpp
@@ -19,6 +19,7 @@
 #include "Common.h"
 #include "Database/DatabaseEnv.h"
 #include "World.h"
+#include "ObjectMgr.h"
 #include "Player.h"
 #include "Opcodes.h"
 #include "Chat.h"
@@ -261,3 +262,75 @@ bool ChatHandler::HandleServerMotdCommand(const char* /*args*/)
     PSendSysMessage(LANG_MOTD_CURRENT, sWorld.GetMotd());
     return true;
 }
+
+// Playerbot mod
+bool ChatHandler::HandlePlayerbotCommand(const char* args)
+{
+    if (! m_session)
+    {
+        PSendSysMessage("You may only add bots from an active session");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if (!*args)
+    {
+        PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    char *cmd = strtok ((char*)args, " ");
+    char *charname = strtok (NULL, " ");
+    if (!cmd || !charname)
+    {
+        PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    std::string cmdStr = cmd;
+    std::string charnameStr = charname;
+
+    if(!normalizePlayerName(charnameStr))
+        return false;
+
+    uint64 guid = objmgr.GetPlayerGUIDByName(charnameStr.c_str());
+    if (guid == 0 || (guid == m_session->GetPlayer()->GetGUID()))
+    {
+        SendSysMessage(LANG_PLAYER_NOT_FOUND);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    uint32 accountId = objmgr.GetPlayerAccountIdByGUID(guid);
+    if (accountId != m_session->GetAccountId()) {
+        PSendSysMessage("You may only add bots from the same account.");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if (cmdStr == "add" || cmdStr == "login")
+    {
+        if (m_session->GetPlayerBot(guid) != NULL) {
+            PSendSysMessage("Bot already exists in world.");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        m_session->AddPlayerBot(guid);
+        PSendSysMessage("Bot added successfully.");
+    }
+    else if (cmdStr == "remove" || cmdStr == "logout")
+    {
+        if (m_session->GetPlayerBot(guid) == NULL) {
+            PSendSysMessage("Bot can not be removed because bot does not exist in world.");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        m_session->LogoutPlayerBot(guid, true);
+        PSendSysMessage("Bot removed successfully.");
+    }
+
+    return true;
+}
+
diff --git a/src/game/Makefile.am b/src/game/Makefile.am
index 96f9ae3..e007ac0 100644
--- a/src/game/Makefile.am
+++ b/src/game/Makefile.am
@@ -209,6 +209,26 @@ libmangosgame_a_SOURCES = \
 	PetitionsHandler.cpp \
 	Player.cpp \
 	Player.h \
+	PlayerbotAI.cpp \
+	PlayerbotAI.h \
+	PlayerbotClassAI.cpp \
+	PlayerbotClassAI.h \
+	PlayerbotDruidAI.cpp \
+	PlayerbotDruidAI.h \
+	PlayerbotMageAI.cpp \
+	PlayerbotMageAI.h \
+	PlayerbotPaladinAI.cpp \
+	PlayerbotPaladinAI.h \
+	PlayerbotPriestAI.cpp \
+	PlayerbotPriestAI.h \
+	PlayerbotRogueAI.cpp \
+	PlayerbotRogueAI.h \
+	PlayerbotShamanAI.cpp \
+	PlayerbotShamanAI.h \
+	PlayerbotWarlockAI.cpp \
+	PlayerbotWarlockAI.h \
+	PlayerbotWarriorAI.cpp \
+	PlayerbotWarriorAI.h \
 	PlayerDump.cpp \
 	PlayerDump.h \
 	PointMovementGenerator.cpp \
diff --git a/src/game/NPCHandler.cpp b/src/game/NPCHandler.cpp
index abbebf6..17fbddc 100644
--- a/src/game/NPCHandler.cpp
+++ b/src/game/NPCHandler.cpp
@@ -279,7 +279,14 @@ void WorldSession::HandleGossipHelloOpcode( WorldPacket & recv_data )
     if(GetPlayer()->hasUnitState(UNIT_STAT_DIED))
         GetPlayer()->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
 
-    if( unit->isArmorer() || unit->isCivilian() || unit->isQuestGiver() || unit->isServiceProvider())
+	if(unit->isBotGiver())
+ 	{
+		GetPlayer()->TalkedToCreature(unit->GetEntry(),unit->GetGUID());
+        unit->prepareGossipMenu(GetPlayer(),GOSSIP_OPTION_BOT);
+        unit->sendPreparedGossip(GetPlayer());
+ 		unit->StopMoving();
+ 	}
+    else if( unit->isArmorer() || unit->isCivilian() || unit->isQuestGiver() || unit->isServiceProvider())
     {
         unit->StopMoving();
     }
@@ -337,6 +344,21 @@ void WorldSession::HandleGossipSelectOptionOpcode( WorldPacket & recv_data )
     if(GetPlayer()->hasUnitState(UNIT_STAT_DIED))
         GetPlayer()->RemoveSpellsCausingAura(SPELL_AURA_FEIGN_DEATH);
 
+	if(unit->isBotGiver())
+	{
+		WorldSession * m_session = _player->GetSession();
+		uint64 guidlo = _player->PlayerTalkClass->GossipOptionSender(option);
+		if(m_session->GetPlayerBot(guidlo) != NULL)
+		{
+			m_session->LogoutPlayerBot(guidlo, true);
+		}
+		else if(m_session->GetPlayerBot(guidlo) == NULL)
+		{
+			m_session->AddPlayerBot(guidlo);
+		}
+		_player->PlayerTalkClass->CloseGossip();
+	}
+
     if(!code.empty())
     {
         if (!Script->GossipSelectWithCode(_player, unit, _player->PlayerTalkClass->GossipOptionSender (option), _player->PlayerTalkClass->GossipOptionAction( option ), code.c_str()))
diff --git a/src/game/Player.cpp b/src/game/Player.cpp
index 818694f..2abada7 100644
--- a/src/game/Player.cpp
+++ b/src/game/Player.cpp
@@ -59,6 +59,9 @@
 #include "SocialMgr.h"
 #include "AchievementMgr.h"
 
+// Playerbot mod:
+#include "PlayerbotAI.h"
+
 #include <cmath>
 
 #define ZONE_UPDATE_INTERVAL (1*IN_MILISECONDS)
@@ -272,6 +275,9 @@ Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputa
 {
     m_transport = 0;
 
+	// Playerbot mod:
+    m_playerbotAI = NULL;
+
     m_speakTime = 0;
     m_speakCount = 0;
 
@@ -509,6 +515,12 @@ Player::~Player ()
 
     delete m_declinedname;
     delete m_runes;
+
+    // Playerbot mod: remove AI if exists
+    if (m_playerbotAI != NULL) {
+        delete m_playerbotAI;
+        m_playerbotAI = NULL;
+    }
 }
 
 void Player::CleanupsBeforeDelete()
@@ -1108,6 +1120,11 @@ void Player::Update( uint32 p_time )
 
     UpdateAfkReport(now);
 
+    // Playerbot mod: this was added as part of the Playerbot mod
+    if (m_playerbotAI != NULL) {
+        m_playerbotAI->UpdateAI(p_time);
+    }
+
     // Update items that have just a limited lifetime
     if (now>m_Last_tick)
         UpdateItemDuration(uint32(now- m_Last_tick));
@@ -1557,6 +1574,14 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
     // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
     Pet* pet = GetPet();
 
+	// Playerbot mod: if this user has bots, tell them to stop following master
+    // so they don't try to follow the master after the master teleports
+    for (PlayerBotMap::const_iterator itr = GetSession()->GetPlayerBotsBegin(); itr != GetSession()->GetPlayerBotsEnd(); ++itr)
+    {
+        Player* botPlayer = itr->second;
+        botPlayer->GetMotionMaster()->Clear();
+    }
+
     MapEntry const* mEntry = sMapStore.LookupEntry(mapid);
 
     // don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
@@ -19958,3 +19983,24 @@ bool Player::canSeeSpellClickOn(Creature const *c) const
     return false;
 }
 
+// Playerbot mod:
+void Player::SetPlayerbotAI(PlayerbotAI * ai) {
+
+    if (ai == NULL) {
+        sLog.outError("Tried to assign playerbot AI to NULL; this is not supported!");
+        return;
+    }
+
+    if (GetPlayerbotAI() != NULL) {
+        sLog.outError("Tried to reassign playerbot AI; this is not yet supported!");
+        return;
+    }
+
+    // assigning bot AI to normal players is not currently supported
+    if (! IsPlayerbot()) {
+        sLog.outError("Tried to set playerbot AI for a player that was not a bot.");
+        return;
+    }
+    m_playerbotAI = ai;
+}
+
diff --git a/src/game/Player.h b/src/game/Player.h
index 6540255..10cb054 100644
--- a/src/game/Player.h
+++ b/src/game/Player.h
@@ -52,6 +52,9 @@ class SpellCastTargets;
 class PlayerSocial;
 class Vehicle;
 
+// Playerbot mod
+class PlayerbotAI;
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS       127
@@ -351,6 +354,12 @@ enum DrunkenState
     DRUNKEN_SMASHED = 3
 };
 
+enum PlayerStateType
+{
+    PLAYER_STATE_NONE              = 0,
+    PLAYER_STATE_SIT               = 1
+};
+
 enum PlayerFlags
 {
     PLAYER_FLAGS_GROUP_LEADER   = 0x00000001,
@@ -2050,6 +2059,11 @@ class MANGOS_DLL_SPEC Player : public Unit
 
         bool isActiveObject() const { return true; }
         bool canSeeSpellClickOn(Creature const* creature) const;
+		// Playerbot mod:
+        void SetPlayerbotAI(PlayerbotAI * ai);
+        PlayerbotAI* GetPlayerbotAI() { return m_playerbotAI; }
+        bool IsPlayerbot() { return (GetSession()->GetRemoteAddress() == "bot"); }
+
     protected:
 
         /*********************************************************/
@@ -2289,6 +2303,9 @@ class MANGOS_DLL_SPEC Player : public Unit
         GridReference<Player> m_gridRef;
         MapReference m_mapRef;
 
+        // Playerbot mod:
+        PlayerbotAI* m_playerbotAI;
+
         uint32 m_lastFallTime;
         float  m_lastFallZ;
 
diff --git a/src/game/SharedDefines.h b/src/game/SharedDefines.h
index b68e364..c592501 100644
--- a/src/game/SharedDefines.h
+++ b/src/game/SharedDefines.h
@@ -203,6 +203,12 @@ enum ItemQualities
     ITEM_QUALITY_HEIRLOOM              = 7
 };
 
+enum SpellCategory
+{
+    SPELL_CATEGORY_FOOD             = 11,
+    SPELL_CATEGORY_DRINK            = 59,
+};
+
 #define MAX_ITEM_QUALITY                 8
 
 // ***********************************
diff --git a/src/game/SpellEffects.cpp b/src/game/SpellEffects.cpp
index ba57067..13db9fd 100644
--- a/src/game/SpellEffects.cpp
+++ b/src/game/SpellEffects.cpp
@@ -5327,6 +5327,8 @@ void Spell::EffectDuel(uint32 i)
     map->Add(pGameObj);
     //END
 
+    // Playerbot moved Send request below (actually moved it back)
+
     // Send request
     WorldPacket data(SMSG_DUEL_REQUESTED, 16);
     data << pGameObj->GetGUID();
diff --git a/src/game/WorldSession.cpp b/src/game/WorldSession.cpp
index ddf4dd8..325ab59 100644
--- a/src/game/WorldSession.cpp
+++ b/src/game/WorldSession.cpp
@@ -37,6 +37,9 @@
 #include "SocialMgr.h"
 #include "zlib/zlib.h"
 
+// Playerbot mod
+#include "PlayerbotAI.h"
+
 /// WorldSession constructor
 WorldSession::WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale) :
 LookingForGroup_auto_join(false), LookingForGroup_auto_add(false), m_muteTime(mute_time),
@@ -54,6 +57,10 @@ _logoutTime(0), m_inQueue(false), m_playerLoading(false), m_playerLogout(false),
 /// WorldSession destructor
 WorldSession::~WorldSession()
 {
+    // Playerbot mod: log out any PlayerBots owned in this WorldSession
+    while (! m_playerBots.empty())
+        LogoutPlayerBot(m_playerBots.begin()->first, true);
+
     ///- unload player if not unloaded
     if (_player)
         LogoutPlayer (true);
@@ -89,6 +96,13 @@ char const* WorldSession::GetPlayerName() const
 /// Send a packet to the client
 void WorldSession::SendPacket(WorldPacket const* packet)
 {
+    // Playerbot mod: send packet to bot AI
+    if (GetPlayer() && GetPlayer()->GetPlayerbotAI())
+        GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(*packet);
+
+    else if (! m_playerBots.empty())
+        PlayerbotAI::HandleMasterOutgoingPacket(*packet, *this);
+
     if (!m_Socket)
         return;
 
@@ -183,6 +197,11 @@ bool WorldSession::Update(uint32 /*diff*/)
                     else if(_player->IsInWorld())
                         (this->*opHandle.handler)(*packet);
                     // lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
+
+                    // Playerbot mod: if this player has bots let the bot AI see the masters packet
+                    if (! m_playerBots.empty())
+                        PlayerbotAI::HandleMasterIncomingPacket(*packet, *this);
+
                     break;
                 case STATUS_TRANSFER_PENDING:
                     if(!_player)
@@ -214,6 +233,25 @@ bool WorldSession::Update(uint32 /*diff*/)
         delete packet;
     }
 
+    // Playerbot mod - Process player bot packets
+    // The PlayerbotAI class adds to the packet queue to simulate a real player
+    // since Playerbots are known to the World obj only its master's WorldSession object
+    // we need to process all master's bot's packets.
+    for (PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr) {
+        Player* const botPlayer = itr->second;
+        WorldSession* const pBotWorldSession = botPlayer->GetSession();
+        if (botPlayer->IsBeingTeleported())
+            pBotWorldSession->HandleMoveWorldportAckOpcode();
+        else if (botPlayer->IsInWorld()) {
+            while (! pBotWorldSession->_recvQueue.empty()) {
+                WorldPacket* const packet = pBotWorldSession->_recvQueue.next();
+                OpcodeHandler& opHandle = opcodeTable[packet->GetOpcode()];
+                (pBotWorldSession->*opHandle.handler)(*packet);
+                delete packet;
+            }
+        }
+    }
+
     ///- Cleanup socket pointer if need
     if (m_Socket && m_Socket->IsClosed ())
     {
@@ -235,6 +273,10 @@ bool WorldSession::Update(uint32 /*diff*/)
 /// %Log the player out
 void WorldSession::LogoutPlayer(bool Save)
 {
+    // Playerbot mod: log out all player bots owned by this toon
+    while (! m_playerBots.empty())
+        LogoutPlayerBot(m_playerBots.begin()->first, Save);
+
     // finish pending transfers before starting the logout
     while(_player && _player->IsBeingTeleportedFar())
         HandleMoveWorldportAckOpcode();
@@ -319,6 +361,7 @@ void WorldSession::LogoutPlayer(bool Save)
         ///- Reset the online field in the account table
         // no point resetting online in character table here as Player::SaveToDB() will set it to 1 since player has not been removed from world at this stage
         //No SQL injection as AccountID is uint32
+        if (! _player->IsPlayerbot())
         loginDatabase.PExecute("UPDATE account SET online = 0 WHERE id = '%u'", GetAccountId());
 
         ///- If the player is in a guild, update the guild roster and broadcast a logout message to other guild members
@@ -384,6 +427,9 @@ void WorldSession::LogoutPlayer(bool Save)
         _player->CleanupsBeforeDelete();                    // do some cleanup before deleting to prevent crash at crossreferences to already deleted data
 
         sSocialMgr.RemovePlayerSocial (_player->GetGUIDLow ());
+
+        uint32 guid = _player->GetGUIDLow();
+
         delete _player;
         _player = NULL;
 
@@ -393,8 +439,7 @@ void WorldSession::LogoutPlayer(bool Save)
 
         ///- Since each account can only have one online character at any given time, ensure all characters for active account are marked as offline
         //No SQL injection as AccountId is uint32
-        CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE account = '%u'",
-            GetAccountId());
+        CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE guid = '%u'", guid);
         sLog.outDebug( "SESSION: Sent SMSG_LOGOUT_COMPLETE Message" );
     }
 
@@ -730,3 +775,24 @@ void WorldSession::SendAddonsInfo()
 
     SendPacket(&data);
 }
+
+// Playerbot mod: logs out a Playerbot.
+void WorldSession::LogoutPlayerBot(uint64 guid, bool Save)
+{
+    Player* botPlayerPtr = GetPlayerBot(guid);
+
+    if (botPlayerPtr)
+    {
+        WorldSession * botWorldSessionPtr = botPlayerPtr->m_session;
+        m_playerBots.erase(guid);    // deletes bot player ptr inside this WorldSession PlayerBotMap
+        botWorldSessionPtr->LogoutPlayer(Save); // this will delete the bot Player object and PlayerbotAI object
+        delete botWorldSessionPtr;  // finally delete the bot's WorldSession
+    }
+}
+
+// Playerbot mod: Gets a player bot Player object for this WorldSession master
+Player* WorldSession::GetPlayerBot(uint64 playerGuid) const
+{
+    PlayerBotMap::const_iterator it = m_playerBots.find(playerGuid);
+    return (it == m_playerBots.end()) ? 0 : it->second;
+}
diff --git a/src/game/WorldSession.h b/src/game/WorldSession.h
index 47a0c67..7871e0d 100644
--- a/src/game/WorldSession.h
+++ b/src/game/WorldSession.h
@@ -93,6 +93,9 @@ enum PartyResult
     PARTY_RESULT_INVITE_RESTRICTED    = 13
 };
 
+// Playerbot mod
+typedef UNORDERED_MAP<uint64, Player*> PlayerBotMap;
+
 /// Player session in the World
 class MANGOS_DLL_SPEC WorldSession
 {
@@ -101,6 +104,13 @@ class MANGOS_DLL_SPEC WorldSession
         WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale);
         ~WorldSession();
 
+        // Playerbot mod
+        void AddPlayerBot(uint64 guid);
+        void LogoutPlayerBot(uint64 guid, bool Save);
+        Player* GetPlayerBot (uint64 guid) const;
+        PlayerBotMap::const_iterator GetPlayerBotsBegin() const { return m_playerBots.begin(); }
+        PlayerBotMap::const_iterator GetPlayerBotsEnd()   const { return m_playerBots.end();   }
+
         bool PlayerLoading() const { return m_playerLoading; }
         bool PlayerLogout() const { return m_playerLogout; }
 
@@ -714,6 +724,8 @@ class MANGOS_DLL_SPEC WorldSession
         AccountData m_accountData[NUM_ACCOUNT_DATA_TYPES];
         AddonsList m_addonsList;
 
+        PlayerBotMap m_playerBots;
+
         ZThread::LockedQueue<WorldPacket*,ZThread::FastMutex> _recvQueue;
 };
 #endif
diff --git a/win/VC90/game.vcproj b/win/VC90/game.vcproj
index a634b2e..913394b 100644
--- a/win/VC90/game.vcproj
+++ b/win/VC90/game.vcproj
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="9,00"
+	Version="9.00"
 	Name="game"
 	ProjectGUID="{1DC6C4DA-A028-41F3-877D-D5400C594F88}"
 	RootNamespace="game"
@@ -101,7 +101,7 @@
 			/>
 		</Configuration>
 		<Configuration
-			Name="Debug|x64"
+			Name="Release|Win32"
 			OutputDirectory=".\game__$(PlatformName)_$(ConfigurationName)"
 			IntermediateDirectory=".\game__$(PlatformName)_$(ConfigurationName)"
 			ConfigurationType="4"
@@ -451,19 +451,17 @@
 			/>
 			<Tool
 				Name="VCMIDLTool"
-				TargetEnvironment="3"
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalOptions="/MP /bigobj"
-				Optimization="0"
+				AdditionalOptions="/MP"
+				InlineFunctionExpansion="1"
 				AdditionalIncludeDirectories="..\..\dep\include;..\..\src\framework;..\..\src\shared;..\..\src\shared\vmap;..\..\dep\ACE_wrappers"
-				PreprocessorDefinitions="WIN32;_DEBUG;MANGOS_DEBUG;_LIB;"
-				StringPooling="false"
-				MinimalRebuild="false"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;"
+				StringPooling="true"
+				RuntimeLibrary="2"
 				EnableFunctionLevelLinking="true"
+				EnableEnhancedInstructionSet="1"
 				RuntimeTypeInfo="true"
 				UsePrecompiledHeader="0"
 				PrecompiledHeaderFile=".\game__$(PlatformName)_$(ConfigurationName)\game.pch"
@@ -482,7 +480,7 @@
 			/>
 			<Tool
 				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
+				PreprocessorDefinitions="NDEBUG"
 				Culture="1033"
 			/>
 			<Tool
@@ -1298,6 +1296,86 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\PlayerbotAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotAI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotClassAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotClassAI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotDruidAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotDruidAI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotMageAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotMageAI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotPaladinAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotPaladinAI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotPriestAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotPriestAI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotRogueAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotRogueAI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotShamanAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotShamanAI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotWarlockAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotWarlockAI.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotWarriorAI.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\PlayerbotWarriorAI.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\PointMovementGenerator.cpp"
 				>
 			</File>
--

